// Copyright 2010-2018 Google LLC
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Linear Programming Protocol Buffers.
//
// The protocol buffers below make it possible to store and transfer the
// representation of Linear and Mixed-Integer Programs.
//
// A Linear Program (LP) is a mathematical optimization model with a linear
// objective function, and linear equality and inequality constraints.
// The goal is to achieve the best outcome (such as maximum profit or lowest
// cost) by modeling the real-world problem at hand using linear functions.
// In a Mixed Integer Program (MIP), some variables may also be constrained to
// take integer values.
//
// Check ./linear_solver.h and Wikipedia for more detail:
//   http://en.wikipedia.org/wiki/Linear_programming
//

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.26.0
// 	protoc        v3.12.4
// source: ortools/linear_solver/linear_solver.proto

package linear_solver

import (
	util "github.com/idledaemon/ortools/gen/util"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	math "math"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Status returned by the solver. They follow a hierarchical nomenclature, to
// allow us to add more enum values in the future. Clients should use
// InCategory() to match these enums, with the following C++ pseudo-code:
//
// bool InCategory(MPSolverResponseStatus status, MPSolverResponseStatus cat) {
//   if (cat == MPSOLVER_OPTIMAL) return status == MPSOLVER_OPTIMAL;
//   while (status > cat) status >>= 4;
//   return status == cat;
// }
type MPSolverResponseStatus int32

const (
	// The solver found the proven optimal solution. This is what should be
	// returned in most cases.
	//
	// WARNING: for historical reason, the value is zero, which means that this
	// value can't have any subcategories.
	MPSolverResponseStatus_MPSOLVER_OPTIMAL MPSolverResponseStatus = 0
	// The solver had enough time to find some solution that satisfies all
	// constraints, but it did not prove optimality (which means it may or may
	// not have reached the optimal).
	//
	// This can happen for large LP models (Linear Programming), and is a frequent
	// response for time-limited MIPs (Mixed Integer Programming). In the MIP
	// case, the difference between the solution 'objective_value' and
	// 'best_objective_bound' fields of the MPSolutionResponse will give an
	// indication of how far this solution is from the optimal one.
	MPSolverResponseStatus_MPSOLVER_FEASIBLE MPSolverResponseStatus = 1
	// The model does not have any solution, according to the solver (which
	// "proved" it, with the caveat that numerical proofs aren't actual proofs),
	// or based on trivial considerations (eg. a variable whose lower bound is
	// strictly greater than its upper bound).
	MPSolverResponseStatus_MPSOLVER_INFEASIBLE MPSolverResponseStatus = 2
	// There exist solutions that make the magnitude of the objective value
	// as large as wanted (i.e. -infinity (resp. +infinity) for a minimization
	// (resp. maximization) problem.
	MPSolverResponseStatus_MPSOLVER_UNBOUNDED MPSolverResponseStatus = 3
	// An error (most probably numerical) occurred.
	// One likely cause for such errors is a large numerical range among variable
	// coefficients (eg. 1e-16, 1e20), in which case one should try to shrink it.
	MPSolverResponseStatus_MPSOLVER_ABNORMAL MPSolverResponseStatus = 4
	// The solver did not have a chance to diagnose the model in one of the
	// categories above.
	MPSolverResponseStatus_MPSOLVER_NOT_SOLVED MPSolverResponseStatus = 6
	// Like "NOT_SOLVED", but typically used by model validation functions
	// returning a "model status", to enhance readability of the client code.
	MPSolverResponseStatus_MPSOLVER_MODEL_IS_VALID MPSolverResponseStatus = 97
	// Special value: the solver status could not be properly translated and is
	// unknown.
	MPSolverResponseStatus_MPSOLVER_UNKNOWN_STATUS MPSolverResponseStatus = 99
	// Model errors. These are always deterministic and repeatable.
	// They should be accompanied with a string description of the error.
	MPSolverResponseStatus_MPSOLVER_MODEL_INVALID MPSolverResponseStatus = 5
	// Something is wrong with the fields "solution_hint_var_index" and/or
	// "solution_hint_var_value".
	MPSolverResponseStatus_MPSOLVER_MODEL_INVALID_SOLUTION_HINT MPSolverResponseStatus = 84
	// Something is wrong with the solver_specific_parameters request field.
	MPSolverResponseStatus_MPSOLVER_MODEL_INVALID_SOLVER_PARAMETERS MPSolverResponseStatus = 85
	// Implementation error: the requested solver implementation is not
	// available (see MPModelRequest.solver_type).
	// The linear solver binary was probably not linked with the required library,
	// eg //ortools/linear_solver:linear_solver_scip for SCIP.
	MPSolverResponseStatus_MPSOLVER_SOLVER_TYPE_UNAVAILABLE MPSolverResponseStatus = 7
)

// Enum value maps for MPSolverResponseStatus.
var (
	MPSolverResponseStatus_name = map[int32]string{
		0:  "MPSOLVER_OPTIMAL",
		1:  "MPSOLVER_FEASIBLE",
		2:  "MPSOLVER_INFEASIBLE",
		3:  "MPSOLVER_UNBOUNDED",
		4:  "MPSOLVER_ABNORMAL",
		6:  "MPSOLVER_NOT_SOLVED",
		97: "MPSOLVER_MODEL_IS_VALID",
		99: "MPSOLVER_UNKNOWN_STATUS",
		5:  "MPSOLVER_MODEL_INVALID",
		84: "MPSOLVER_MODEL_INVALID_SOLUTION_HINT",
		85: "MPSOLVER_MODEL_INVALID_SOLVER_PARAMETERS",
		7:  "MPSOLVER_SOLVER_TYPE_UNAVAILABLE",
	}
	MPSolverResponseStatus_value = map[string]int32{
		"MPSOLVER_OPTIMAL":                         0,
		"MPSOLVER_FEASIBLE":                        1,
		"MPSOLVER_INFEASIBLE":                      2,
		"MPSOLVER_UNBOUNDED":                       3,
		"MPSOLVER_ABNORMAL":                        4,
		"MPSOLVER_NOT_SOLVED":                      6,
		"MPSOLVER_MODEL_IS_VALID":                  97,
		"MPSOLVER_UNKNOWN_STATUS":                  99,
		"MPSOLVER_MODEL_INVALID":                   5,
		"MPSOLVER_MODEL_INVALID_SOLUTION_HINT":     84,
		"MPSOLVER_MODEL_INVALID_SOLVER_PARAMETERS": 85,
		"MPSOLVER_SOLVER_TYPE_UNAVAILABLE":         7,
	}
)

func (x MPSolverResponseStatus) Enum() *MPSolverResponseStatus {
	p := new(MPSolverResponseStatus)
	*p = x
	return p
}

func (x MPSolverResponseStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MPSolverResponseStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_ortools_linear_solver_linear_solver_proto_enumTypes[0].Descriptor()
}

func (MPSolverResponseStatus) Type() protoreflect.EnumType {
	return &file_ortools_linear_solver_linear_solver_proto_enumTypes[0]
}

func (x MPSolverResponseStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *MPSolverResponseStatus) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = MPSolverResponseStatus(num)
	return nil
}

// Deprecated: Use MPSolverResponseStatus.Descriptor instead.
func (MPSolverResponseStatus) EnumDescriptor() ([]byte, []int) {
	return file_ortools_linear_solver_linear_solver_proto_rawDescGZIP(), []int{0}
}

type MPSosConstraint_Type int32

const (
	// At most one variable in `var_index` must be non-zero.
	MPSosConstraint_SOS1_DEFAULT MPSosConstraint_Type = 0
	// At most two consecutive variables from `var_index` can be non-zero (i.e.
	// for some i, var_index[i] and var_index[i+1]). See
	// http://www.eudoxus.com/lp-training/5/5-6-special-ordered-sets-of-type-2
	MPSosConstraint_SOS2 MPSosConstraint_Type = 1
)

// Enum value maps for MPSosConstraint_Type.
var (
	MPSosConstraint_Type_name = map[int32]string{
		0: "SOS1_DEFAULT",
		1: "SOS2",
	}
	MPSosConstraint_Type_value = map[string]int32{
		"SOS1_DEFAULT": 0,
		"SOS2":         1,
	}
)

func (x MPSosConstraint_Type) Enum() *MPSosConstraint_Type {
	p := new(MPSosConstraint_Type)
	*p = x
	return p
}

func (x MPSosConstraint_Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MPSosConstraint_Type) Descriptor() protoreflect.EnumDescriptor {
	return file_ortools_linear_solver_linear_solver_proto_enumTypes[1].Descriptor()
}

func (MPSosConstraint_Type) Type() protoreflect.EnumType {
	return &file_ortools_linear_solver_linear_solver_proto_enumTypes[1]
}

func (x MPSosConstraint_Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *MPSosConstraint_Type) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = MPSosConstraint_Type(num)
	return nil
}

// Deprecated: Use MPSosConstraint_Type.Descriptor instead.
func (MPSosConstraint_Type) EnumDescriptor() ([]byte, []int) {
	return file_ortools_linear_solver_linear_solver_proto_rawDescGZIP(), []int{4, 0}
}

type MPSolverCommonParameters_LPAlgorithmValues int32

const (
	MPSolverCommonParameters_LP_ALGO_UNSPECIFIED MPSolverCommonParameters_LPAlgorithmValues = 0
	MPSolverCommonParameters_LP_ALGO_DUAL        MPSolverCommonParameters_LPAlgorithmValues = 1 // Dual simplex.
	MPSolverCommonParameters_LP_ALGO_PRIMAL      MPSolverCommonParameters_LPAlgorithmValues = 2 // Primal simplex.
	MPSolverCommonParameters_LP_ALGO_BARRIER     MPSolverCommonParameters_LPAlgorithmValues = 3 // Barrier algorithm.
)

// Enum value maps for MPSolverCommonParameters_LPAlgorithmValues.
var (
	MPSolverCommonParameters_LPAlgorithmValues_name = map[int32]string{
		0: "LP_ALGO_UNSPECIFIED",
		1: "LP_ALGO_DUAL",
		2: "LP_ALGO_PRIMAL",
		3: "LP_ALGO_BARRIER",
	}
	MPSolverCommonParameters_LPAlgorithmValues_value = map[string]int32{
		"LP_ALGO_UNSPECIFIED": 0,
		"LP_ALGO_DUAL":        1,
		"LP_ALGO_PRIMAL":      2,
		"LP_ALGO_BARRIER":     3,
	}
)

func (x MPSolverCommonParameters_LPAlgorithmValues) Enum() *MPSolverCommonParameters_LPAlgorithmValues {
	p := new(MPSolverCommonParameters_LPAlgorithmValues)
	*p = x
	return p
}

func (x MPSolverCommonParameters_LPAlgorithmValues) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MPSolverCommonParameters_LPAlgorithmValues) Descriptor() protoreflect.EnumDescriptor {
	return file_ortools_linear_solver_linear_solver_proto_enumTypes[2].Descriptor()
}

func (MPSolverCommonParameters_LPAlgorithmValues) Type() protoreflect.EnumType {
	return &file_ortools_linear_solver_linear_solver_proto_enumTypes[2]
}

func (x MPSolverCommonParameters_LPAlgorithmValues) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *MPSolverCommonParameters_LPAlgorithmValues) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = MPSolverCommonParameters_LPAlgorithmValues(num)
	return nil
}

// Deprecated: Use MPSolverCommonParameters_LPAlgorithmValues.Descriptor instead.
func (MPSolverCommonParameters_LPAlgorithmValues) EnumDescriptor() ([]byte, []int) {
	return file_ortools_linear_solver_linear_solver_proto_rawDescGZIP(), []int{13, 0}
}

// The solver type, which will select a specific implementation, and will also
// impact the interpretation of the model (i.e. are we solving the problem
// as a mixed integer program or are we relaxing it as a continuous linear
// program?).
// This must remain consistent with MPSolver::OptimizationProblemType.
type MPModelRequest_SolverType int32

const (
	MPModelRequest_GLOP_LINEAR_PROGRAMMING          MPModelRequest_SolverType = 2 // Recommended default for LP models.
	MPModelRequest_CLP_LINEAR_PROGRAMMING           MPModelRequest_SolverType = 0
	MPModelRequest_GLPK_LINEAR_PROGRAMMING          MPModelRequest_SolverType = 1
	MPModelRequest_GUROBI_LINEAR_PROGRAMMING        MPModelRequest_SolverType = 6   // Commercial, needs a valid license.
	MPModelRequest_XPRESS_LINEAR_PROGRAMMING        MPModelRequest_SolverType = 101 // Commercial, needs a valid license. NOLINT
	MPModelRequest_CPLEX_LINEAR_PROGRAMMING         MPModelRequest_SolverType = 10  // Commercial, needs a valid license. NOLINT
	MPModelRequest_SCIP_MIXED_INTEGER_PROGRAMMING   MPModelRequest_SolverType = 3   // Recommended default for MIP models.
	MPModelRequest_GLPK_MIXED_INTEGER_PROGRAMMING   MPModelRequest_SolverType = 4
	MPModelRequest_CBC_MIXED_INTEGER_PROGRAMMING    MPModelRequest_SolverType = 5
	MPModelRequest_GUROBI_MIXED_INTEGER_PROGRAMMING MPModelRequest_SolverType = 7   // Commercial, needs a valid license.
	MPModelRequest_XPRESS_MIXED_INTEGER_PROGRAMMING MPModelRequest_SolverType = 102 // Commercial, needs a valid license. NOLINT
	MPModelRequest_CPLEX_MIXED_INTEGER_PROGRAMMING  MPModelRequest_SolverType = 11  // Commercial, needs a valid license. NOLINT
	MPModelRequest_BOP_INTEGER_PROGRAMMING          MPModelRequest_SolverType = 12
	// WARNING: This solver will currently interpret all variables as integer,
	// so any solution you get will be valid, but the optimal might be far away
	// for the real one (when you authorise non-integer value for continuous
	// variables).
	MPModelRequest_SAT_INTEGER_PROGRAMMING            MPModelRequest_SolverType = 14
	MPModelRequest_KNAPSACK_MIXED_INTEGER_PROGRAMMING MPModelRequest_SolverType = 13
)

// Enum value maps for MPModelRequest_SolverType.
var (
	MPModelRequest_SolverType_name = map[int32]string{
		2:   "GLOP_LINEAR_PROGRAMMING",
		0:   "CLP_LINEAR_PROGRAMMING",
		1:   "GLPK_LINEAR_PROGRAMMING",
		6:   "GUROBI_LINEAR_PROGRAMMING",
		101: "XPRESS_LINEAR_PROGRAMMING",
		10:  "CPLEX_LINEAR_PROGRAMMING",
		3:   "SCIP_MIXED_INTEGER_PROGRAMMING",
		4:   "GLPK_MIXED_INTEGER_PROGRAMMING",
		5:   "CBC_MIXED_INTEGER_PROGRAMMING",
		7:   "GUROBI_MIXED_INTEGER_PROGRAMMING",
		102: "XPRESS_MIXED_INTEGER_PROGRAMMING",
		11:  "CPLEX_MIXED_INTEGER_PROGRAMMING",
		12:  "BOP_INTEGER_PROGRAMMING",
		14:  "SAT_INTEGER_PROGRAMMING",
		13:  "KNAPSACK_MIXED_INTEGER_PROGRAMMING",
	}
	MPModelRequest_SolverType_value = map[string]int32{
		"GLOP_LINEAR_PROGRAMMING":            2,
		"CLP_LINEAR_PROGRAMMING":             0,
		"GLPK_LINEAR_PROGRAMMING":            1,
		"GUROBI_LINEAR_PROGRAMMING":          6,
		"XPRESS_LINEAR_PROGRAMMING":          101,
		"CPLEX_LINEAR_PROGRAMMING":           10,
		"SCIP_MIXED_INTEGER_PROGRAMMING":     3,
		"GLPK_MIXED_INTEGER_PROGRAMMING":     4,
		"CBC_MIXED_INTEGER_PROGRAMMING":      5,
		"GUROBI_MIXED_INTEGER_PROGRAMMING":   7,
		"XPRESS_MIXED_INTEGER_PROGRAMMING":   102,
		"CPLEX_MIXED_INTEGER_PROGRAMMING":    11,
		"BOP_INTEGER_PROGRAMMING":            12,
		"SAT_INTEGER_PROGRAMMING":            14,
		"KNAPSACK_MIXED_INTEGER_PROGRAMMING": 13,
	}
)

func (x MPModelRequest_SolverType) Enum() *MPModelRequest_SolverType {
	p := new(MPModelRequest_SolverType)
	*p = x
	return p
}

func (x MPModelRequest_SolverType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MPModelRequest_SolverType) Descriptor() protoreflect.EnumDescriptor {
	return file_ortools_linear_solver_linear_solver_proto_enumTypes[3].Descriptor()
}

func (MPModelRequest_SolverType) Type() protoreflect.EnumType {
	return &file_ortools_linear_solver_linear_solver_proto_enumTypes[3]
}

func (x MPModelRequest_SolverType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *MPModelRequest_SolverType) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = MPModelRequest_SolverType(num)
	return nil
}

// Deprecated: Use MPModelRequest_SolverType.Descriptor instead.
func (MPModelRequest_SolverType) EnumDescriptor() ([]byte, []int) {
	return file_ortools_linear_solver_linear_solver_proto_rawDescGZIP(), []int{15, 0}
}

// A variable is always constrained in the form:
//    lower_bound <= x <= upper_bound
// where lower_bound and upper_bound:
// - Can form a singleton: x = constant = lower_bound = upper_bound.
// - Can form a finite interval: lower_bound <= x <= upper_bound. (x is boxed.)
// - Can form a semi-infinite interval.
//     - lower_bound = -infinity: x <= upper_bound.
//     - upper_bound = +infinity: x >= lower_bound.
// - Can form the infinite interval: lower_bound = -infinity and
//   upper_bound = +infinity, x is free.
// MPVariableProto furthermore stores:
//  - The coefficient of the variable in the objective.
//  - Whether the variable is integer.
type MPVariableProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// lower_bound must be <= upper_bound.
	LowerBound *float64 `protobuf:"fixed64,1,opt,name=lower_bound,json=lowerBound,def=-inf" json:"lower_bound,omitempty"`
	UpperBound *float64 `protobuf:"fixed64,2,opt,name=upper_bound,json=upperBound,def=inf" json:"upper_bound,omitempty"`
	// The coefficient of the variable in the objective. Must be finite.
	ObjectiveCoefficient *float64 `protobuf:"fixed64,3,opt,name=objective_coefficient,json=objectiveCoefficient,def=0" json:"objective_coefficient,omitempty"`
	// True if the variable is constrained to be integer.
	// Ignored if MPModelProto::solver_type is *LINEAR_PROGRAMMING*.
	IsInteger *bool `protobuf:"varint,4,opt,name=is_integer,json=isInteger,def=0" json:"is_integer,omitempty"`
	// The name of the variable.
	Name              *string `protobuf:"bytes,5,opt,name=name,def=" json:"name,omitempty"`
	BranchingPriority *int32  `protobuf:"varint,6,opt,name=branching_priority,json=branchingPriority,def=0" json:"branching_priority,omitempty"`
}

// Default values for MPVariableProto fields.
const (
	Default_MPVariableProto_ObjectiveCoefficient = float64(0)
	Default_MPVariableProto_IsInteger            = bool(false)
	Default_MPVariableProto_Name                 = string("")
	Default_MPVariableProto_BranchingPriority    = int32(0)
)

// Default values for MPVariableProto fields.
var (
	Default_MPVariableProto_LowerBound = float64(math.Inf(-1))
	Default_MPVariableProto_UpperBound = float64(math.Inf(+1))
)

func (x *MPVariableProto) Reset() {
	*x = MPVariableProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ortools_linear_solver_linear_solver_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MPVariableProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MPVariableProto) ProtoMessage() {}

func (x *MPVariableProto) ProtoReflect() protoreflect.Message {
	mi := &file_ortools_linear_solver_linear_solver_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MPVariableProto.ProtoReflect.Descriptor instead.
func (*MPVariableProto) Descriptor() ([]byte, []int) {
	return file_ortools_linear_solver_linear_solver_proto_rawDescGZIP(), []int{0}
}

func (x *MPVariableProto) GetLowerBound() float64 {
	if x != nil && x.LowerBound != nil {
		return *x.LowerBound
	}
	return Default_MPVariableProto_LowerBound
}

func (x *MPVariableProto) GetUpperBound() float64 {
	if x != nil && x.UpperBound != nil {
		return *x.UpperBound
	}
	return Default_MPVariableProto_UpperBound
}

func (x *MPVariableProto) GetObjectiveCoefficient() float64 {
	if x != nil && x.ObjectiveCoefficient != nil {
		return *x.ObjectiveCoefficient
	}
	return Default_MPVariableProto_ObjectiveCoefficient
}

func (x *MPVariableProto) GetIsInteger() bool {
	if x != nil && x.IsInteger != nil {
		return *x.IsInteger
	}
	return Default_MPVariableProto_IsInteger
}

func (x *MPVariableProto) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return Default_MPVariableProto_Name
}

func (x *MPVariableProto) GetBranchingPriority() int32 {
	if x != nil && x.BranchingPriority != nil {
		return *x.BranchingPriority
	}
	return Default_MPVariableProto_BranchingPriority
}

// A linear constraint is always of the form:
// lower_bound <= sum of linear term elements <= upper_bound,
// where lower_bound and upper_bound:
// - Can form a singleton: lower_bound == upper_bound. The constraint is an
//   equation.
// - Can form a finite interval [lower_bound, upper_bound]. The constraint is
//   both lower- and upper-bounded, i.e. "boxed".
// - Can form a semi-infinite interval. lower_bound = -infinity: the constraint
//   is upper-bounded. upper_bound = +infinity: the constraint is lower-bounded.
// - Can form the infinite interval: lower_bound = -infinity and
//   upper_bound = +infinity. The constraint is free.
type MPConstraintProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// var_index[i] is the variable index (w.r.t. to "variable" field of
	// MPModelProto) of the i-th linear term involved in this constraint, and
	// coefficient[i] is its coefficient. Only the terms with non-zero
	// coefficients need to appear. var_index may not contain duplicates.
	VarIndex    []int32   `protobuf:"varint,6,rep,packed,name=var_index,json=varIndex" json:"var_index,omitempty"`
	Coefficient []float64 `protobuf:"fixed64,7,rep,packed,name=coefficient" json:"coefficient,omitempty"` // Must be finite.
	// lower_bound must be <= upper_bound.
	LowerBound *float64 `protobuf:"fixed64,2,opt,name=lower_bound,json=lowerBound,def=-inf" json:"lower_bound,omitempty"`
	UpperBound *float64 `protobuf:"fixed64,3,opt,name=upper_bound,json=upperBound,def=inf" json:"upper_bound,omitempty"`
	// The name of the constraint.
	Name *string `protobuf:"bytes,4,opt,name=name,def=" json:"name,omitempty"`
	// [Advanced usage: do not use this if you don't know what you're doing.]
	// A lazy constraint is handled differently by the core solving engine, but
	// it does not change the result. It may or may not impact the performance.
	// For more info see: http://tinyurl.com/lazy-constraints.
	IsLazy *bool `protobuf:"varint,5,opt,name=is_lazy,json=isLazy,def=0" json:"is_lazy,omitempty"`
}

// Default values for MPConstraintProto fields.
const (
	Default_MPConstraintProto_Name   = string("")
	Default_MPConstraintProto_IsLazy = bool(false)
)

// Default values for MPConstraintProto fields.
var (
	Default_MPConstraintProto_LowerBound = float64(math.Inf(-1))
	Default_MPConstraintProto_UpperBound = float64(math.Inf(+1))
)

func (x *MPConstraintProto) Reset() {
	*x = MPConstraintProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ortools_linear_solver_linear_solver_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MPConstraintProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MPConstraintProto) ProtoMessage() {}

func (x *MPConstraintProto) ProtoReflect() protoreflect.Message {
	mi := &file_ortools_linear_solver_linear_solver_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MPConstraintProto.ProtoReflect.Descriptor instead.
func (*MPConstraintProto) Descriptor() ([]byte, []int) {
	return file_ortools_linear_solver_linear_solver_proto_rawDescGZIP(), []int{1}
}

func (x *MPConstraintProto) GetVarIndex() []int32 {
	if x != nil {
		return x.VarIndex
	}
	return nil
}

func (x *MPConstraintProto) GetCoefficient() []float64 {
	if x != nil {
		return x.Coefficient
	}
	return nil
}

func (x *MPConstraintProto) GetLowerBound() float64 {
	if x != nil && x.LowerBound != nil {
		return *x.LowerBound
	}
	return Default_MPConstraintProto_LowerBound
}

func (x *MPConstraintProto) GetUpperBound() float64 {
	if x != nil && x.UpperBound != nil {
		return *x.UpperBound
	}
	return Default_MPConstraintProto_UpperBound
}

func (x *MPConstraintProto) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return Default_MPConstraintProto_Name
}

func (x *MPConstraintProto) GetIsLazy() bool {
	if x != nil && x.IsLazy != nil {
		return *x.IsLazy
	}
	return Default_MPConstraintProto_IsLazy
}

// General constraints. See each individual proto type for more information.
type MPGeneralConstraintProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The name of the constraint.
	Name *string `protobuf:"bytes,1,opt,name=name,def=" json:"name,omitempty"`
	// Types that are assignable to GeneralConstraint:
	//	*MPGeneralConstraintProto_IndicatorConstraint
	//	*MPGeneralConstraintProto_SosConstraint
	//	*MPGeneralConstraintProto_QuadraticConstraint
	//	*MPGeneralConstraintProto_AbsConstraint
	//	*MPGeneralConstraintProto_AndConstraint
	//	*MPGeneralConstraintProto_OrConstraint
	//	*MPGeneralConstraintProto_MinConstraint
	//	*MPGeneralConstraintProto_MaxConstraint
	GeneralConstraint isMPGeneralConstraintProto_GeneralConstraint `protobuf_oneof:"general_constraint"`
}

// Default values for MPGeneralConstraintProto fields.
const (
	Default_MPGeneralConstraintProto_Name = string("")
)

func (x *MPGeneralConstraintProto) Reset() {
	*x = MPGeneralConstraintProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ortools_linear_solver_linear_solver_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MPGeneralConstraintProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MPGeneralConstraintProto) ProtoMessage() {}

func (x *MPGeneralConstraintProto) ProtoReflect() protoreflect.Message {
	mi := &file_ortools_linear_solver_linear_solver_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MPGeneralConstraintProto.ProtoReflect.Descriptor instead.
func (*MPGeneralConstraintProto) Descriptor() ([]byte, []int) {
	return file_ortools_linear_solver_linear_solver_proto_rawDescGZIP(), []int{2}
}

func (x *MPGeneralConstraintProto) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return Default_MPGeneralConstraintProto_Name
}

func (m *MPGeneralConstraintProto) GetGeneralConstraint() isMPGeneralConstraintProto_GeneralConstraint {
	if m != nil {
		return m.GeneralConstraint
	}
	return nil
}

func (x *MPGeneralConstraintProto) GetIndicatorConstraint() *MPIndicatorConstraint {
	if x, ok := x.GetGeneralConstraint().(*MPGeneralConstraintProto_IndicatorConstraint); ok {
		return x.IndicatorConstraint
	}
	return nil
}

func (x *MPGeneralConstraintProto) GetSosConstraint() *MPSosConstraint {
	if x, ok := x.GetGeneralConstraint().(*MPGeneralConstraintProto_SosConstraint); ok {
		return x.SosConstraint
	}
	return nil
}

func (x *MPGeneralConstraintProto) GetQuadraticConstraint() *MPQuadraticConstraint {
	if x, ok := x.GetGeneralConstraint().(*MPGeneralConstraintProto_QuadraticConstraint); ok {
		return x.QuadraticConstraint
	}
	return nil
}

func (x *MPGeneralConstraintProto) GetAbsConstraint() *MPAbsConstraint {
	if x, ok := x.GetGeneralConstraint().(*MPGeneralConstraintProto_AbsConstraint); ok {
		return x.AbsConstraint
	}
	return nil
}

func (x *MPGeneralConstraintProto) GetAndConstraint() *MPArrayConstraint {
	if x, ok := x.GetGeneralConstraint().(*MPGeneralConstraintProto_AndConstraint); ok {
		return x.AndConstraint
	}
	return nil
}

func (x *MPGeneralConstraintProto) GetOrConstraint() *MPArrayConstraint {
	if x, ok := x.GetGeneralConstraint().(*MPGeneralConstraintProto_OrConstraint); ok {
		return x.OrConstraint
	}
	return nil
}

func (x *MPGeneralConstraintProto) GetMinConstraint() *MPArrayWithConstantConstraint {
	if x, ok := x.GetGeneralConstraint().(*MPGeneralConstraintProto_MinConstraint); ok {
		return x.MinConstraint
	}
	return nil
}

func (x *MPGeneralConstraintProto) GetMaxConstraint() *MPArrayWithConstantConstraint {
	if x, ok := x.GetGeneralConstraint().(*MPGeneralConstraintProto_MaxConstraint); ok {
		return x.MaxConstraint
	}
	return nil
}

type isMPGeneralConstraintProto_GeneralConstraint interface {
	isMPGeneralConstraintProto_GeneralConstraint()
}

type MPGeneralConstraintProto_IndicatorConstraint struct {
	IndicatorConstraint *MPIndicatorConstraint `protobuf:"bytes,2,opt,name=indicator_constraint,json=indicatorConstraint,oneof"`
}

type MPGeneralConstraintProto_SosConstraint struct {
	SosConstraint *MPSosConstraint `protobuf:"bytes,3,opt,name=sos_constraint,json=sosConstraint,oneof"`
}

type MPGeneralConstraintProto_QuadraticConstraint struct {
	QuadraticConstraint *MPQuadraticConstraint `protobuf:"bytes,4,opt,name=quadratic_constraint,json=quadraticConstraint,oneof"`
}

type MPGeneralConstraintProto_AbsConstraint struct {
	AbsConstraint *MPAbsConstraint `protobuf:"bytes,5,opt,name=abs_constraint,json=absConstraint,oneof"`
}

type MPGeneralConstraintProto_AndConstraint struct {
	// All variables in "and" constraints must be Boolean.
	// resultant_var = and(var_1, var_2... var_n)
	AndConstraint *MPArrayConstraint `protobuf:"bytes,6,opt,name=and_constraint,json=andConstraint,oneof"`
}

type MPGeneralConstraintProto_OrConstraint struct {
	// All variables in "or" constraints must be Boolean.
	// resultant_var = or(var_1, var_2... var_n)
	OrConstraint *MPArrayConstraint `protobuf:"bytes,7,opt,name=or_constraint,json=orConstraint,oneof"`
}

type MPGeneralConstraintProto_MinConstraint struct {
	// resultant_var = min(var_1, var_2, ..., constant)
	MinConstraint *MPArrayWithConstantConstraint `protobuf:"bytes,8,opt,name=min_constraint,json=minConstraint,oneof"`
}

type MPGeneralConstraintProto_MaxConstraint struct {
	// resultant_var = max(var_1, var_2, ..., constant)
	MaxConstraint *MPArrayWithConstantConstraint `protobuf:"bytes,9,opt,name=max_constraint,json=maxConstraint,oneof"`
}

func (*MPGeneralConstraintProto_IndicatorConstraint) isMPGeneralConstraintProto_GeneralConstraint() {}

func (*MPGeneralConstraintProto_SosConstraint) isMPGeneralConstraintProto_GeneralConstraint() {}

func (*MPGeneralConstraintProto_QuadraticConstraint) isMPGeneralConstraintProto_GeneralConstraint() {}

func (*MPGeneralConstraintProto_AbsConstraint) isMPGeneralConstraintProto_GeneralConstraint() {}

func (*MPGeneralConstraintProto_AndConstraint) isMPGeneralConstraintProto_GeneralConstraint() {}

func (*MPGeneralConstraintProto_OrConstraint) isMPGeneralConstraintProto_GeneralConstraint() {}

func (*MPGeneralConstraintProto_MinConstraint) isMPGeneralConstraintProto_GeneralConstraint() {}

func (*MPGeneralConstraintProto_MaxConstraint) isMPGeneralConstraintProto_GeneralConstraint() {}

// Indicator constraints encode the activation or deactivation of linear
// constraints given the value of one Boolean variable in the model. For
// example:
//     y = 0 => 2 * x1 + 3 * x2 >= 42
// The 2 * x1 + 3 * x2 >= 42 constraint is only active if the variable y is
// equal to 0.
// As of 2019/04, only SCIP, CP-SAT and Gurobi support this constraint type.
type MPIndicatorConstraint struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Variable index (w.r.t. the "variable" field of MPModelProto) of the Boolean
	// variable used as indicator.
	VarIndex *int32 `protobuf:"varint,1,opt,name=var_index,json=varIndex" json:"var_index,omitempty"`
	// Value the above variable should take. Must be 0 or 1.
	VarValue *int32 `protobuf:"varint,2,opt,name=var_value,json=varValue" json:"var_value,omitempty"`
	// The constraint activated by the indicator variable.
	Constraint *MPConstraintProto `protobuf:"bytes,3,opt,name=constraint" json:"constraint,omitempty"`
}

func (x *MPIndicatorConstraint) Reset() {
	*x = MPIndicatorConstraint{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ortools_linear_solver_linear_solver_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MPIndicatorConstraint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MPIndicatorConstraint) ProtoMessage() {}

func (x *MPIndicatorConstraint) ProtoReflect() protoreflect.Message {
	mi := &file_ortools_linear_solver_linear_solver_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MPIndicatorConstraint.ProtoReflect.Descriptor instead.
func (*MPIndicatorConstraint) Descriptor() ([]byte, []int) {
	return file_ortools_linear_solver_linear_solver_proto_rawDescGZIP(), []int{3}
}

func (x *MPIndicatorConstraint) GetVarIndex() int32 {
	if x != nil && x.VarIndex != nil {
		return *x.VarIndex
	}
	return 0
}

func (x *MPIndicatorConstraint) GetVarValue() int32 {
	if x != nil && x.VarValue != nil {
		return *x.VarValue
	}
	return 0
}

func (x *MPIndicatorConstraint) GetConstraint() *MPConstraintProto {
	if x != nil {
		return x.Constraint
	}
	return nil
}

// Special Ordered Set (SOS) constraints of type 1 or 2.
// See https://en.wikipedia.org/wiki/Special_ordered_set
// As of 2019/04, only SCIP and Gurobi support this constraint type.
type MPSosConstraint struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Type *MPSosConstraint_Type `protobuf:"varint,1,opt,name=type,enum=operations_research.MPSosConstraint_Type,def=0" json:"type,omitempty"`
	// Variable index (w.r.t. the "variable" field of MPModelProto) of the
	// variables in the SOS.
	VarIndex []int32 `protobuf:"varint,2,rep,name=var_index,json=varIndex" json:"var_index,omitempty"`
	// Optional: SOS weights. If non-empty, must be of the same size as
	// "var_index", and strictly increasing. If empty and required by the
	// underlying solver, the 1..n sequence will be given as weights.
	// SUBTLE: The weights can help the solver make branch-and-bound decisions
	// that fit the underlying optimization model: after each LP relaxation, it
	// will compute the "average weight" of the SOS variables, weighted by value
	// (this is confusing: here we're using the values as weights), and the binary
	// branch decision will be: is the non-zero variable above or below that?
	// (weights are strictly monotonous, so the "cutoff" average weight
	// corresponds to a "cutoff" index in the var_index sequence).
	Weight []float64 `protobuf:"fixed64,3,rep,name=weight" json:"weight,omitempty"`
}

// Default values for MPSosConstraint fields.
const (
	Default_MPSosConstraint_Type = MPSosConstraint_SOS1_DEFAULT
)

func (x *MPSosConstraint) Reset() {
	*x = MPSosConstraint{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ortools_linear_solver_linear_solver_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MPSosConstraint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MPSosConstraint) ProtoMessage() {}

func (x *MPSosConstraint) ProtoReflect() protoreflect.Message {
	mi := &file_ortools_linear_solver_linear_solver_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MPSosConstraint.ProtoReflect.Descriptor instead.
func (*MPSosConstraint) Descriptor() ([]byte, []int) {
	return file_ortools_linear_solver_linear_solver_proto_rawDescGZIP(), []int{4}
}

func (x *MPSosConstraint) GetType() MPSosConstraint_Type {
	if x != nil && x.Type != nil {
		return *x.Type
	}
	return Default_MPSosConstraint_Type
}

func (x *MPSosConstraint) GetVarIndex() []int32 {
	if x != nil {
		return x.VarIndex
	}
	return nil
}

func (x *MPSosConstraint) GetWeight() []float64 {
	if x != nil {
		return x.Weight
	}
	return nil
}

// Quadratic constraints of the form lb <= sum a_i x_i + sum b_ij x_i x_j <= ub,
// where a, b, lb and ub are constants, and x are the model's variables.
// Quadratic matrices that are Positive Semi-Definite, Second-Order Cones or
// rotated Second-Order Cones are always accepted. Other forms may or may not be
// accepted depending on the underlying solver used.
// See https://scip.zib.de/doc/html/cons__quadratic_8h.php and
// https://www.gurobi.com/documentation/8.1/refman/constraints.html#subsubsection:QuadraticConstraints
type MPQuadraticConstraint struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Sparse representation of linear terms in the quadratic constraint, where
	// term i is var_index[i] * coefficient[i].
	// `var_index` are variable indices w.r.t the "variable" field in
	// MPModelProto, and should be unique.
	VarIndex    []int32   `protobuf:"varint,1,rep,name=var_index,json=varIndex" json:"var_index,omitempty"`
	Coefficient []float64 `protobuf:"fixed64,2,rep,name=coefficient" json:"coefficient,omitempty"` // Must be finite.
	// Sparse representation of quadratic terms in the quadratic constraint, where
	// term i is qvar1_index[i] * qvar2_index[i] * qcoefficient[i].
	// `qvar1_index` and `qvar2_index` are variable indices w.r.t the "variable"
	// field in MPModelProto.
	// `qvar1_index`, `qvar2_index` and `coefficients` must have the same size.
	// If the same unordered pair (qvar1_index, qvar2_index) appears several
	// times, the sum of all of the associated coefficients will be applied.
	Qvar1Index   []int32   `protobuf:"varint,3,rep,name=qvar1_index,json=qvar1Index" json:"qvar1_index,omitempty"`
	Qvar2Index   []int32   `protobuf:"varint,4,rep,name=qvar2_index,json=qvar2Index" json:"qvar2_index,omitempty"`
	Qcoefficient []float64 `protobuf:"fixed64,5,rep,name=qcoefficient" json:"qcoefficient,omitempty"` // Must be finite.
	// lower_bound must be <= upper_bound.
	LowerBound *float64 `protobuf:"fixed64,6,opt,name=lower_bound,json=lowerBound,def=-inf" json:"lower_bound,omitempty"`
	UpperBound *float64 `protobuf:"fixed64,7,opt,name=upper_bound,json=upperBound,def=inf" json:"upper_bound,omitempty"`
}

// Default values for MPQuadraticConstraint fields.
var (
	Default_MPQuadraticConstraint_LowerBound = float64(math.Inf(-1))
	Default_MPQuadraticConstraint_UpperBound = float64(math.Inf(+1))
)

func (x *MPQuadraticConstraint) Reset() {
	*x = MPQuadraticConstraint{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ortools_linear_solver_linear_solver_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MPQuadraticConstraint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MPQuadraticConstraint) ProtoMessage() {}

func (x *MPQuadraticConstraint) ProtoReflect() protoreflect.Message {
	mi := &file_ortools_linear_solver_linear_solver_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MPQuadraticConstraint.ProtoReflect.Descriptor instead.
func (*MPQuadraticConstraint) Descriptor() ([]byte, []int) {
	return file_ortools_linear_solver_linear_solver_proto_rawDescGZIP(), []int{5}
}

func (x *MPQuadraticConstraint) GetVarIndex() []int32 {
	if x != nil {
		return x.VarIndex
	}
	return nil
}

func (x *MPQuadraticConstraint) GetCoefficient() []float64 {
	if x != nil {
		return x.Coefficient
	}
	return nil
}

func (x *MPQuadraticConstraint) GetQvar1Index() []int32 {
	if x != nil {
		return x.Qvar1Index
	}
	return nil
}

func (x *MPQuadraticConstraint) GetQvar2Index() []int32 {
	if x != nil {
		return x.Qvar2Index
	}
	return nil
}

func (x *MPQuadraticConstraint) GetQcoefficient() []float64 {
	if x != nil {
		return x.Qcoefficient
	}
	return nil
}

func (x *MPQuadraticConstraint) GetLowerBound() float64 {
	if x != nil && x.LowerBound != nil {
		return *x.LowerBound
	}
	return Default_MPQuadraticConstraint_LowerBound
}

func (x *MPQuadraticConstraint) GetUpperBound() float64 {
	if x != nil && x.UpperBound != nil {
		return *x.UpperBound
	}
	return Default_MPQuadraticConstraint_UpperBound
}

// Sets a variable's value to the absolute value of another variable.
type MPAbsConstraint struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Variable indices are relative to the "variable" field in MPModelProto.
	// resultant_var = abs(var)
	VarIndex          *int32 `protobuf:"varint,1,opt,name=var_index,json=varIndex" json:"var_index,omitempty"`
	ResultantVarIndex *int32 `protobuf:"varint,2,opt,name=resultant_var_index,json=resultantVarIndex" json:"resultant_var_index,omitempty"`
}

func (x *MPAbsConstraint) Reset() {
	*x = MPAbsConstraint{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ortools_linear_solver_linear_solver_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MPAbsConstraint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MPAbsConstraint) ProtoMessage() {}

func (x *MPAbsConstraint) ProtoReflect() protoreflect.Message {
	mi := &file_ortools_linear_solver_linear_solver_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MPAbsConstraint.ProtoReflect.Descriptor instead.
func (*MPAbsConstraint) Descriptor() ([]byte, []int) {
	return file_ortools_linear_solver_linear_solver_proto_rawDescGZIP(), []int{6}
}

func (x *MPAbsConstraint) GetVarIndex() int32 {
	if x != nil && x.VarIndex != nil {
		return *x.VarIndex
	}
	return 0
}

func (x *MPAbsConstraint) GetResultantVarIndex() int32 {
	if x != nil && x.ResultantVarIndex != nil {
		return *x.ResultantVarIndex
	}
	return 0
}

// Sets a variable's value equal to a function on a set of variables.
type MPArrayConstraint struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Variable indices are relative to the "variable" field in MPModelProto.
	VarIndex          []int32 `protobuf:"varint,1,rep,name=var_index,json=varIndex" json:"var_index,omitempty"`
	ResultantVarIndex *int32  `protobuf:"varint,2,opt,name=resultant_var_index,json=resultantVarIndex" json:"resultant_var_index,omitempty"`
}

func (x *MPArrayConstraint) Reset() {
	*x = MPArrayConstraint{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ortools_linear_solver_linear_solver_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MPArrayConstraint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MPArrayConstraint) ProtoMessage() {}

func (x *MPArrayConstraint) ProtoReflect() protoreflect.Message {
	mi := &file_ortools_linear_solver_linear_solver_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MPArrayConstraint.ProtoReflect.Descriptor instead.
func (*MPArrayConstraint) Descriptor() ([]byte, []int) {
	return file_ortools_linear_solver_linear_solver_proto_rawDescGZIP(), []int{7}
}

func (x *MPArrayConstraint) GetVarIndex() []int32 {
	if x != nil {
		return x.VarIndex
	}
	return nil
}

func (x *MPArrayConstraint) GetResultantVarIndex() int32 {
	if x != nil && x.ResultantVarIndex != nil {
		return *x.ResultantVarIndex
	}
	return 0
}

// Sets a variable's value equal to a function on a set of variables and,
// optionally, a constant.
type MPArrayWithConstantConstraint struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Variable indices are relative to the "variable" field in MPModelProto.
	// resultant_var = f(var_1, var_2, ..., constant)
	VarIndex          []int32  `protobuf:"varint,1,rep,name=var_index,json=varIndex" json:"var_index,omitempty"`
	Constant          *float64 `protobuf:"fixed64,2,opt,name=constant" json:"constant,omitempty"`
	ResultantVarIndex *int32   `protobuf:"varint,3,opt,name=resultant_var_index,json=resultantVarIndex" json:"resultant_var_index,omitempty"`
}

func (x *MPArrayWithConstantConstraint) Reset() {
	*x = MPArrayWithConstantConstraint{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ortools_linear_solver_linear_solver_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MPArrayWithConstantConstraint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MPArrayWithConstantConstraint) ProtoMessage() {}

func (x *MPArrayWithConstantConstraint) ProtoReflect() protoreflect.Message {
	mi := &file_ortools_linear_solver_linear_solver_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MPArrayWithConstantConstraint.ProtoReflect.Descriptor instead.
func (*MPArrayWithConstantConstraint) Descriptor() ([]byte, []int) {
	return file_ortools_linear_solver_linear_solver_proto_rawDescGZIP(), []int{8}
}

func (x *MPArrayWithConstantConstraint) GetVarIndex() []int32 {
	if x != nil {
		return x.VarIndex
	}
	return nil
}

func (x *MPArrayWithConstantConstraint) GetConstant() float64 {
	if x != nil && x.Constant != nil {
		return *x.Constant
	}
	return 0
}

func (x *MPArrayWithConstantConstraint) GetResultantVarIndex() int32 {
	if x != nil && x.ResultantVarIndex != nil {
		return *x.ResultantVarIndex
	}
	return 0
}

// Quadratic part of a model's objective. Added with other objectives (such as
// linear), this creates the model's objective function to be optimized.
// Note: the linear part of the objective currently needs to be specified in the
// MPVariableProto.objective_coefficient fields. If you'd rather have a
// dedicated linear array here, talk to or-core-team@
type MPQuadraticObjective struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Sparse representation of quadratic terms in the objective function, where
	// term i is qvar1_index[i] * qvar2_index[i] * coefficient[i].
	// `qvar1_index` and `qvar2_index` are variable indices w.r.t the "variable"
	// field in MPModelProto.
	// `qvar1_index`, `qvar2_index` and `coefficients` must have the same size.
	// If the same unordered pair (qvar1_index, qvar2_index) appears several
	// times, the sum of all of the associated coefficients will be applied.
	Qvar1Index  []int32   `protobuf:"varint,1,rep,name=qvar1_index,json=qvar1Index" json:"qvar1_index,omitempty"`
	Qvar2Index  []int32   `protobuf:"varint,2,rep,name=qvar2_index,json=qvar2Index" json:"qvar2_index,omitempty"`
	Coefficient []float64 `protobuf:"fixed64,3,rep,name=coefficient" json:"coefficient,omitempty"` // Must be finite.
}

func (x *MPQuadraticObjective) Reset() {
	*x = MPQuadraticObjective{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ortools_linear_solver_linear_solver_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MPQuadraticObjective) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MPQuadraticObjective) ProtoMessage() {}

func (x *MPQuadraticObjective) ProtoReflect() protoreflect.Message {
	mi := &file_ortools_linear_solver_linear_solver_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MPQuadraticObjective.ProtoReflect.Descriptor instead.
func (*MPQuadraticObjective) Descriptor() ([]byte, []int) {
	return file_ortools_linear_solver_linear_solver_proto_rawDescGZIP(), []int{9}
}

func (x *MPQuadraticObjective) GetQvar1Index() []int32 {
	if x != nil {
		return x.Qvar1Index
	}
	return nil
}

func (x *MPQuadraticObjective) GetQvar2Index() []int32 {
	if x != nil {
		return x.Qvar2Index
	}
	return nil
}

func (x *MPQuadraticObjective) GetCoefficient() []float64 {
	if x != nil {
		return x.Coefficient
	}
	return nil
}

// This message encodes a partial (or full) assignment of the variables of a
// MPModelProto problem. The indices in var_index should be unique and valid
// variable indices of the associated problem.
type PartialVariableAssignment struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	VarIndex []int32   `protobuf:"varint,1,rep,packed,name=var_index,json=varIndex" json:"var_index,omitempty"`
	VarValue []float64 `protobuf:"fixed64,2,rep,packed,name=var_value,json=varValue" json:"var_value,omitempty"`
}

func (x *PartialVariableAssignment) Reset() {
	*x = PartialVariableAssignment{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ortools_linear_solver_linear_solver_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PartialVariableAssignment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PartialVariableAssignment) ProtoMessage() {}

func (x *PartialVariableAssignment) ProtoReflect() protoreflect.Message {
	mi := &file_ortools_linear_solver_linear_solver_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PartialVariableAssignment.ProtoReflect.Descriptor instead.
func (*PartialVariableAssignment) Descriptor() ([]byte, []int) {
	return file_ortools_linear_solver_linear_solver_proto_rawDescGZIP(), []int{10}
}

func (x *PartialVariableAssignment) GetVarIndex() []int32 {
	if x != nil {
		return x.VarIndex
	}
	return nil
}

func (x *PartialVariableAssignment) GetVarValue() []float64 {
	if x != nil {
		return x.VarValue
	}
	return nil
}

// MPModelProto contains all the information for a Linear Programming model.
type MPModelProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// All the variables appearing in the model.
	Variable []*MPVariableProto `protobuf:"bytes,3,rep,name=variable" json:"variable,omitempty"`
	// All the constraints appearing in the model.
	Constraint []*MPConstraintProto `protobuf:"bytes,4,rep,name=constraint" json:"constraint,omitempty"`
	// All the general constraints appearing in the model. Note that not all
	// solvers support all types of general constraints.
	GeneralConstraint []*MPGeneralConstraintProto `protobuf:"bytes,7,rep,name=general_constraint,json=generalConstraint" json:"general_constraint,omitempty"`
	// True if the problem is a maximization problem. Minimize by default.
	Maximize *bool `protobuf:"varint,1,opt,name=maximize,def=0" json:"maximize,omitempty"`
	// Offset for the objective function. Must be finite.
	ObjectiveOffset *float64 `protobuf:"fixed64,2,opt,name=objective_offset,json=objectiveOffset,def=0" json:"objective_offset,omitempty"`
	// Optionally, a quadratic objective.
	// As of 2019/06, only SCIP and Gurobi support quadratic objectives.
	QuadraticObjective *MPQuadraticObjective `protobuf:"bytes,8,opt,name=quadratic_objective,json=quadraticObjective" json:"quadratic_objective,omitempty"`
	// Name of the model.
	Name *string `protobuf:"bytes,5,opt,name=name,def=" json:"name,omitempty"`
	// Solution hint.
	//
	// If a feasible or almost-feasible solution to the problem is already known,
	// it may be helpful to pass it to the solver so that it can be used. A solver
	// that supports this feature will try to use this information to create its
	// initial feasible solution.
	//
	// Note that it may not always be faster to give a hint like this to the
	// solver. There is also no guarantee that the solver will use this hint or
	// try to return a solution "close" to this assignment in case of multiple
	// optimal solutions.
	SolutionHint *PartialVariableAssignment `protobuf:"bytes,6,opt,name=solution_hint,json=solutionHint" json:"solution_hint,omitempty"`
}

// Default values for MPModelProto fields.
const (
	Default_MPModelProto_Maximize        = bool(false)
	Default_MPModelProto_ObjectiveOffset = float64(0)
	Default_MPModelProto_Name            = string("")
)

func (x *MPModelProto) Reset() {
	*x = MPModelProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ortools_linear_solver_linear_solver_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MPModelProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MPModelProto) ProtoMessage() {}

func (x *MPModelProto) ProtoReflect() protoreflect.Message {
	mi := &file_ortools_linear_solver_linear_solver_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MPModelProto.ProtoReflect.Descriptor instead.
func (*MPModelProto) Descriptor() ([]byte, []int) {
	return file_ortools_linear_solver_linear_solver_proto_rawDescGZIP(), []int{11}
}

func (x *MPModelProto) GetVariable() []*MPVariableProto {
	if x != nil {
		return x.Variable
	}
	return nil
}

func (x *MPModelProto) GetConstraint() []*MPConstraintProto {
	if x != nil {
		return x.Constraint
	}
	return nil
}

func (x *MPModelProto) GetGeneralConstraint() []*MPGeneralConstraintProto {
	if x != nil {
		return x.GeneralConstraint
	}
	return nil
}

func (x *MPModelProto) GetMaximize() bool {
	if x != nil && x.Maximize != nil {
		return *x.Maximize
	}
	return Default_MPModelProto_Maximize
}

func (x *MPModelProto) GetObjectiveOffset() float64 {
	if x != nil && x.ObjectiveOffset != nil {
		return *x.ObjectiveOffset
	}
	return Default_MPModelProto_ObjectiveOffset
}

func (x *MPModelProto) GetQuadraticObjective() *MPQuadraticObjective {
	if x != nil {
		return x.QuadraticObjective
	}
	return nil
}

func (x *MPModelProto) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return Default_MPModelProto_Name
}

func (x *MPModelProto) GetSolutionHint() *PartialVariableAssignment {
	if x != nil {
		return x.SolutionHint
	}
	return nil
}

// To support 'unspecified' double value in proto3, the simplest is to wrap
// any double value in a nested message (has_XXX works for message fields).
// We don't use google/protobuf/wrappers.proto because depending on it makes
// the following android integration test fail:
// http://sponge/c4bce1fd-41bd-4d0b-b4ca-fc04d4d64621
type OptionalDouble struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Value *float64 `protobuf:"fixed64,1,opt,name=value" json:"value,omitempty"`
}

func (x *OptionalDouble) Reset() {
	*x = OptionalDouble{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ortools_linear_solver_linear_solver_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *OptionalDouble) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OptionalDouble) ProtoMessage() {}

func (x *OptionalDouble) ProtoReflect() protoreflect.Message {
	mi := &file_ortools_linear_solver_linear_solver_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OptionalDouble.ProtoReflect.Descriptor instead.
func (*OptionalDouble) Descriptor() ([]byte, []int) {
	return file_ortools_linear_solver_linear_solver_proto_rawDescGZIP(), []int{12}
}

func (x *OptionalDouble) GetValue() float64 {
	if x != nil && x.Value != nil {
		return *x.Value
	}
	return 0
}

// MPSolverCommonParameters holds advanced usage parameters that apply to any of
// the solvers we support.
// All of the fields in this proto can have a value of unspecified. In this
// case each inner solver will use their own safe defaults.
// Some values won't be supported by some solvers. The behavior in that case is
// not defined yet.
type MPSolverCommonParameters struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The solver stops if the relative MIP gap reaches this value or below.
	// The relative MIP gap is an upper bound of the relative distance to the
	// optimum, and it is defined as:
	//
	//   abs(best_bound - incumbent) / abs(incumbent) [Gurobi]
	//   abs(best_bound - incumbent) / min(abs(best_bound), abs(incumbent)) [SCIP]
	//
	// where "incumbent" is the objective value of the best solution found so far
	// (i.e., lowest when minimizing, highest when maximizing), and "best_bound"
	// is the tightest bound of the objective determined so far (i.e., highest
	// when minimizing, and lowest when maximizing). The MIP Gap is sensitive to
	// objective offset. If the denominator is 0 the MIP Gap is INFINITY for SCIP
	// and Gurobi. Of note, "incumbent" and "best bound" are called "primal bound"
	// and "dual bound" in SCIP, respectively.
	// Ask or-core-team@ for other solvers.
	RelativeMipGap *OptionalDouble `protobuf:"bytes,1,opt,name=relative_mip_gap,json=relativeMipGap" json:"relative_mip_gap,omitempty"`
	// Tolerance for primal feasibility of basic solutions: this is the maximum
	// allowed error in constraint satisfiability.
	// For SCIP this includes integrality constraints. For Gurobi it does not, you
	// need to set the custom parameter IntFeasTol.
	PrimalTolerance *OptionalDouble `protobuf:"bytes,2,opt,name=primal_tolerance,json=primalTolerance" json:"primal_tolerance,omitempty"`
	// Tolerance for dual feasibility.
	// For SCIP and Gurobi this is the feasibility tolerance for reduced costs in
	// LP solution: reduced costs must all be smaller than this value in the
	// improving direction in order for a model to be declared optimal.
	// Not supported for other solvers.
	DualTolerance *OptionalDouble `protobuf:"bytes,3,opt,name=dual_tolerance,json=dualTolerance" json:"dual_tolerance,omitempty"`
	// Algorithm to solve linear programs.
	// Ask or-core-team@ if you want to know what this does exactly.
	LpAlgorithm *MPSolverCommonParameters_LPAlgorithmValues `protobuf:"varint,4,opt,name=lp_algorithm,json=lpAlgorithm,enum=operations_research.MPSolverCommonParameters_LPAlgorithmValues,def=0" json:"lp_algorithm,omitempty"`
	// Gurobi and SCIP enable presolve by default.
	// Ask or-core-team@ for other solvers.
	Presolve *util.OptionalBoolean `protobuf:"varint,5,opt,name=presolve,enum=operations_research.OptionalBoolean,def=0" json:"presolve,omitempty"`
	// Enable automatic scaling of matrix coefficients and objective. Available
	// for Gurobi and GLOP.
	// Ask or-core-team@ if you want more details.
	Scaling *util.OptionalBoolean `protobuf:"varint,7,opt,name=scaling,enum=operations_research.OptionalBoolean,def=0" json:"scaling,omitempty"`
}

// Default values for MPSolverCommonParameters fields.
const (
	Default_MPSolverCommonParameters_LpAlgorithm = MPSolverCommonParameters_LP_ALGO_UNSPECIFIED
	Default_MPSolverCommonParameters_Presolve    = util.OptionalBoolean_BOOL_UNSPECIFIED
	Default_MPSolverCommonParameters_Scaling     = util.OptionalBoolean_BOOL_UNSPECIFIED
)

func (x *MPSolverCommonParameters) Reset() {
	*x = MPSolverCommonParameters{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ortools_linear_solver_linear_solver_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MPSolverCommonParameters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MPSolverCommonParameters) ProtoMessage() {}

func (x *MPSolverCommonParameters) ProtoReflect() protoreflect.Message {
	mi := &file_ortools_linear_solver_linear_solver_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MPSolverCommonParameters.ProtoReflect.Descriptor instead.
func (*MPSolverCommonParameters) Descriptor() ([]byte, []int) {
	return file_ortools_linear_solver_linear_solver_proto_rawDescGZIP(), []int{13}
}

func (x *MPSolverCommonParameters) GetRelativeMipGap() *OptionalDouble {
	if x != nil {
		return x.RelativeMipGap
	}
	return nil
}

func (x *MPSolverCommonParameters) GetPrimalTolerance() *OptionalDouble {
	if x != nil {
		return x.PrimalTolerance
	}
	return nil
}

func (x *MPSolverCommonParameters) GetDualTolerance() *OptionalDouble {
	if x != nil {
		return x.DualTolerance
	}
	return nil
}

func (x *MPSolverCommonParameters) GetLpAlgorithm() MPSolverCommonParameters_LPAlgorithmValues {
	if x != nil && x.LpAlgorithm != nil {
		return *x.LpAlgorithm
	}
	return Default_MPSolverCommonParameters_LpAlgorithm
}

func (x *MPSolverCommonParameters) GetPresolve() util.OptionalBoolean {
	if x != nil && x.Presolve != nil {
		return *x.Presolve
	}
	return Default_MPSolverCommonParameters_Presolve
}

func (x *MPSolverCommonParameters) GetScaling() util.OptionalBoolean {
	if x != nil && x.Scaling != nil {
		return *x.Scaling
	}
	return Default_MPSolverCommonParameters_Scaling
}

// Encodes a full MPModelProto by way of referencing to a "baseline"
// MPModelProto stored in a file, and a "delta" to apply to this model.
type MPModelDeltaProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	BaselineModelFilePath *string `protobuf:"bytes,1,opt,name=baseline_model_file_path,json=baselineModelFilePath" json:"baseline_model_file_path,omitempty"`
	// The variable protos listed here will override (via MergeFrom()) the ones
	// in the baseline model: you only need to specify the fields that change.
	// To add a new variable, add it with a new variable index (variable indices
	// still need to span a dense integer interval).
	// You can't "delete" a variable but you can "neutralize" it by fixing its
	// value, setting its objective coefficient to zero, and by nullifying all
	// the terms involving it in the constraints.
	VariableOverrides map[int32]*MPVariableProto `protobuf:"bytes,2,rep,name=variable_overrides,json=variableOverrides" json:"variable_overrides,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Constraints can be changed (or added) in the same way as variables, see
	// above. It's mostly like applying MergeFrom(), except that:
	// - the "var_index" and "coefficient" fields will be overridden like a map:
	//   if a key pre-exists, we overwrite its value, otherwise we add it.
	// - if you set the lower bound to -inf and the upper bound to +inf, thus
	//   effectively neutralizing the constraint, the solver will implicitly
	//   remove all of the constraint's terms.
	ConstraintOverrides map[int32]*MPConstraintProto `protobuf:"bytes,3,rep,name=constraint_overrides,json=constraintOverrides" json:"constraint_overrides,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (x *MPModelDeltaProto) Reset() {
	*x = MPModelDeltaProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ortools_linear_solver_linear_solver_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MPModelDeltaProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MPModelDeltaProto) ProtoMessage() {}

func (x *MPModelDeltaProto) ProtoReflect() protoreflect.Message {
	mi := &file_ortools_linear_solver_linear_solver_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MPModelDeltaProto.ProtoReflect.Descriptor instead.
func (*MPModelDeltaProto) Descriptor() ([]byte, []int) {
	return file_ortools_linear_solver_linear_solver_proto_rawDescGZIP(), []int{14}
}

func (x *MPModelDeltaProto) GetBaselineModelFilePath() string {
	if x != nil && x.BaselineModelFilePath != nil {
		return *x.BaselineModelFilePath
	}
	return ""
}

func (x *MPModelDeltaProto) GetVariableOverrides() map[int32]*MPVariableProto {
	if x != nil {
		return x.VariableOverrides
	}
	return nil
}

func (x *MPModelDeltaProto) GetConstraintOverrides() map[int32]*MPConstraintProto {
	if x != nil {
		return x.ConstraintOverrides
	}
	return nil
}

// Next id: 9.
type MPModelRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The model to be optimized by the server.
	Model      *MPModelProto              `protobuf:"bytes,1,opt,name=model" json:"model,omitempty"`
	SolverType *MPModelRequest_SolverType `protobuf:"varint,2,opt,name=solver_type,json=solverType,enum=operations_research.MPModelRequest_SolverType" json:"solver_type,omitempty"`
	// Maximum time to be spent by the solver to solve 'model'. If the server is
	// busy and the RPC's deadline_left is less than this, it will immediately
	// give up and return an error, without even trying to solve.
	//
	// The client can use this to have a guarantee on how much time the
	// solver will spend on the problem (unless it finds and proves
	// an optimal solution more quickly).
	//
	// If not specified, the time limit on the solver is the RPC's deadline_left.
	SolverTimeLimitSeconds *float64 `protobuf:"fixed64,3,opt,name=solver_time_limit_seconds,json=solverTimeLimitSeconds" json:"solver_time_limit_seconds,omitempty"`
	// If this is set, then EnableOutput() will be set on the internal MPSolver
	// that solves the model.
	// WARNING: if you set this on a request to prod servers, it will be rejected
	// and yield the RPC Application Error code MPSOLVER_SOLVER_TYPE_UNAVAILABLE.
	EnableInternalSolverOutput *bool `protobuf:"varint,4,opt,name=enable_internal_solver_output,json=enableInternalSolverOutput,def=0" json:"enable_internal_solver_output,omitempty"`
	// Advanced usage. Solver-specific parameters in the solver's own format,
	// different for each solver. For example, if you use SCIP and you want to
	// stop the solve earlier than the time limit if it reached a solution that is
	// at most 1% away from the optimal, you can set this to "limits/gap=0.01".
	//
	// Note however that there is no "security" mechanism in place so it is up to
	// the client to make sure that the given options don't make the solve
	// non thread safe or use up too much memory for instance.
	//
	// If the option format is not understood by the solver, the request will be
	// rejected and yield an RPC Application error with code
	// MPSOLVER_MODEL_INVALID_SOLVER_PARAMETERS.
	SolverSpecificParameters *string `protobuf:"bytes,5,opt,name=solver_specific_parameters,json=solverSpecificParameters" json:"solver_specific_parameters,omitempty"`
	// Advanced usage: model "delta". If used, "model" must be unset. See the
	// definition of MPModelDeltaProto.
	ModelDelta *MPModelDeltaProto `protobuf:"bytes,8,opt,name=model_delta,json=modelDelta" json:"model_delta,omitempty"`
}

// Default values for MPModelRequest fields.
const (
	Default_MPModelRequest_EnableInternalSolverOutput = bool(false)
)

func (x *MPModelRequest) Reset() {
	*x = MPModelRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ortools_linear_solver_linear_solver_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MPModelRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MPModelRequest) ProtoMessage() {}

func (x *MPModelRequest) ProtoReflect() protoreflect.Message {
	mi := &file_ortools_linear_solver_linear_solver_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MPModelRequest.ProtoReflect.Descriptor instead.
func (*MPModelRequest) Descriptor() ([]byte, []int) {
	return file_ortools_linear_solver_linear_solver_proto_rawDescGZIP(), []int{15}
}

func (x *MPModelRequest) GetModel() *MPModelProto {
	if x != nil {
		return x.Model
	}
	return nil
}

func (x *MPModelRequest) GetSolverType() MPModelRequest_SolverType {
	if x != nil && x.SolverType != nil {
		return *x.SolverType
	}
	return MPModelRequest_GLOP_LINEAR_PROGRAMMING
}

func (x *MPModelRequest) GetSolverTimeLimitSeconds() float64 {
	if x != nil && x.SolverTimeLimitSeconds != nil {
		return *x.SolverTimeLimitSeconds
	}
	return 0
}

func (x *MPModelRequest) GetEnableInternalSolverOutput() bool {
	if x != nil && x.EnableInternalSolverOutput != nil {
		return *x.EnableInternalSolverOutput
	}
	return Default_MPModelRequest_EnableInternalSolverOutput
}

func (x *MPModelRequest) GetSolverSpecificParameters() string {
	if x != nil && x.SolverSpecificParameters != nil {
		return *x.SolverSpecificParameters
	}
	return ""
}

func (x *MPModelRequest) GetModelDelta() *MPModelDeltaProto {
	if x != nil {
		return x.ModelDelta
	}
	return nil
}

type MPSolutionResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Result of the optimization.
	Status *MPSolverResponseStatus `protobuf:"varint,1,opt,name=status,enum=operations_research.MPSolverResponseStatus,def=99" json:"status,omitempty"`
	// Human-readable string giving more details about the status. For example,
	// when the status is MPSOLVER_INVALID_MODE, this can hold a description of
	// why the model is invalid.
	// This isn't always filled: don't depend on its value or even its presence.
	StatusStr *string `protobuf:"bytes,7,opt,name=status_str,json=statusStr" json:"status_str,omitempty"`
	// Objective value corresponding to the "variable_value" below, taking into
	// account the source "objective_offset" and "objective_coefficient".
	// This is set iff 'status' is OPTIMAL or FEASIBLE.
	ObjectiveValue *float64 `protobuf:"fixed64,2,opt,name=objective_value,json=objectiveValue" json:"objective_value,omitempty"`
	// This field is only filled for MIP problems. For a minimization problem,
	// this is a lower bound on the optimal objective value. For a maximization
	// problem, it is an upper bound. It is only filled if the status is OPTIMAL
	// or FEASIBLE. In the former case, best_objective_bound should be equal to
	// objective_value (modulo numerical errors).
	BestObjectiveBound *float64 `protobuf:"fixed64,5,opt,name=best_objective_bound,json=bestObjectiveBound" json:"best_objective_bound,omitempty"`
	// Variable values in the same order as the MPModelProto::variable field.
	// This is a dense representation. These are set iff 'status' is OPTIMAL or
	// FEASIBLE.
	VariableValue []float64 `protobuf:"fixed64,3,rep,packed,name=variable_value,json=variableValue" json:"variable_value,omitempty"`
	// [Advanced usage.]
	// Values of the dual variables values in the same order as the
	// MPModelProto::constraint field. This is a dense representation.
	// These are not set if the problem was solved with a MIP solver (even if
	// it is actually a linear program).
	// These are set iff 'status' is OPTIMAL or FEASIBLE.
	DualValue []float64 `protobuf:"fixed64,4,rep,packed,name=dual_value,json=dualValue" json:"dual_value,omitempty"`
	// [Advanced usage.]
	// Values of the reduced cost of the variables in the same order as the
	// MPModelProto::variable. This is a dense representation.
	// These are not set if the problem was solved with a MIP solver (even if it
	// is actually a linear program).
	// These are set iff 'status' is OPTIMAL or FEASIBLE.
	ReducedCost []float64 `protobuf:"fixed64,6,rep,packed,name=reduced_cost,json=reducedCost" json:"reduced_cost,omitempty"`
}

// Default values for MPSolutionResponse fields.
const (
	Default_MPSolutionResponse_Status = MPSolverResponseStatus_MPSOLVER_UNKNOWN_STATUS
)

func (x *MPSolutionResponse) Reset() {
	*x = MPSolutionResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ortools_linear_solver_linear_solver_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MPSolutionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MPSolutionResponse) ProtoMessage() {}

func (x *MPSolutionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_ortools_linear_solver_linear_solver_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MPSolutionResponse.ProtoReflect.Descriptor instead.
func (*MPSolutionResponse) Descriptor() ([]byte, []int) {
	return file_ortools_linear_solver_linear_solver_proto_rawDescGZIP(), []int{16}
}

func (x *MPSolutionResponse) GetStatus() MPSolverResponseStatus {
	if x != nil && x.Status != nil {
		return *x.Status
	}
	return Default_MPSolutionResponse_Status
}

func (x *MPSolutionResponse) GetStatusStr() string {
	if x != nil && x.StatusStr != nil {
		return *x.StatusStr
	}
	return ""
}

func (x *MPSolutionResponse) GetObjectiveValue() float64 {
	if x != nil && x.ObjectiveValue != nil {
		return *x.ObjectiveValue
	}
	return 0
}

func (x *MPSolutionResponse) GetBestObjectiveBound() float64 {
	if x != nil && x.BestObjectiveBound != nil {
		return *x.BestObjectiveBound
	}
	return 0
}

func (x *MPSolutionResponse) GetVariableValue() []float64 {
	if x != nil {
		return x.VariableValue
	}
	return nil
}

func (x *MPSolutionResponse) GetDualValue() []float64 {
	if x != nil {
		return x.DualValue
	}
	return nil
}

func (x *MPSolutionResponse) GetReducedCost() []float64 {
	if x != nil {
		return x.ReducedCost
	}
	return nil
}

var File_ortools_linear_solver_linear_solver_proto protoreflect.FileDescriptor

var file_ortools_linear_solver_linear_solver_proto_rawDesc = []byte{
	0x0a, 0x29, 0x6f, 0x72, 0x74, 0x6f, 0x6f, 0x6c, 0x73, 0x2f, 0x6c, 0x69, 0x6e, 0x65, 0x61, 0x72,
	0x5f, 0x73, 0x6f, 0x6c, 0x76, 0x65, 0x72, 0x2f, 0x6c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x5f, 0x73,
	0x6f, 0x6c, 0x76, 0x65, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x13, 0x6f, 0x70, 0x65,
	0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68,
	0x1a, 0x23, 0x6f, 0x72, 0x74, 0x6f, 0x6f, 0x6c, 0x73, 0x2f, 0x75, 0x74, 0x69, 0x6c, 0x2f, 0x6f,
	0x70, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x5f, 0x62, 0x6f, 0x6f, 0x6c, 0x65, 0x61, 0x6e, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x84, 0x02, 0x0a, 0x0f, 0x4d, 0x50, 0x56, 0x61, 0x72, 0x69,
	0x61, 0x62, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x25, 0x0a, 0x0b, 0x6c, 0x6f, 0x77,
	0x65, 0x72, 0x5f, 0x62, 0x6f, 0x75, 0x6e, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x01, 0x3a, 0x04,
	0x2d, 0x69, 0x6e, 0x66, 0x52, 0x0a, 0x6c, 0x6f, 0x77, 0x65, 0x72, 0x42, 0x6f, 0x75, 0x6e, 0x64,
	0x12, 0x24, 0x0a, 0x0b, 0x75, 0x70, 0x70, 0x65, 0x72, 0x5f, 0x62, 0x6f, 0x75, 0x6e, 0x64, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x01, 0x3a, 0x03, 0x69, 0x6e, 0x66, 0x52, 0x0a, 0x75, 0x70, 0x70, 0x65,
	0x72, 0x42, 0x6f, 0x75, 0x6e, 0x64, 0x12, 0x36, 0x0a, 0x15, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74,
	0x69, 0x76, 0x65, 0x5f, 0x63, 0x6f, 0x65, 0x66, 0x66, 0x69, 0x63, 0x69, 0x65, 0x6e, 0x74, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x01, 0x3a, 0x01, 0x30, 0x52, 0x14, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74,
	0x69, 0x76, 0x65, 0x43, 0x6f, 0x65, 0x66, 0x66, 0x69, 0x63, 0x69, 0x65, 0x6e, 0x74, 0x12, 0x24,
	0x0a, 0x0a, 0x69, 0x73, 0x5f, 0x69, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x18, 0x04, 0x20, 0x01,
	0x28, 0x08, 0x3a, 0x05, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x52, 0x09, 0x69, 0x73, 0x49, 0x6e, 0x74,
	0x65, 0x67, 0x65, 0x72, 0x12, 0x14, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x05, 0x20, 0x01,
	0x28, 0x09, 0x3a, 0x00, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x30, 0x0a, 0x12, 0x62, 0x72,
	0x61, 0x6e, 0x63, 0x68, 0x69, 0x6e, 0x67, 0x5f, 0x70, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79,
	0x18, 0x06, 0x20, 0x01, 0x28, 0x05, 0x3a, 0x01, 0x30, 0x52, 0x11, 0x62, 0x72, 0x61, 0x6e, 0x63,
	0x68, 0x69, 0x6e, 0x67, 0x50, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x22, 0xdd, 0x01, 0x0a,
	0x11, 0x4d, 0x50, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f,
	0x74, 0x6f, 0x12, 0x1f, 0x0a, 0x09, 0x76, 0x61, 0x72, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18,
	0x06, 0x20, 0x03, 0x28, 0x05, 0x42, 0x02, 0x10, 0x01, 0x52, 0x08, 0x76, 0x61, 0x72, 0x49, 0x6e,
	0x64, 0x65, 0x78, 0x12, 0x24, 0x0a, 0x0b, 0x63, 0x6f, 0x65, 0x66, 0x66, 0x69, 0x63, 0x69, 0x65,
	0x6e, 0x74, 0x18, 0x07, 0x20, 0x03, 0x28, 0x01, 0x42, 0x02, 0x10, 0x01, 0x52, 0x0b, 0x63, 0x6f,
	0x65, 0x66, 0x66, 0x69, 0x63, 0x69, 0x65, 0x6e, 0x74, 0x12, 0x25, 0x0a, 0x0b, 0x6c, 0x6f, 0x77,
	0x65, 0x72, 0x5f, 0x62, 0x6f, 0x75, 0x6e, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x01, 0x3a, 0x04,
	0x2d, 0x69, 0x6e, 0x66, 0x52, 0x0a, 0x6c, 0x6f, 0x77, 0x65, 0x72, 0x42, 0x6f, 0x75, 0x6e, 0x64,
	0x12, 0x24, 0x0a, 0x0b, 0x75, 0x70, 0x70, 0x65, 0x72, 0x5f, 0x62, 0x6f, 0x75, 0x6e, 0x64, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x01, 0x3a, 0x03, 0x69, 0x6e, 0x66, 0x52, 0x0a, 0x75, 0x70, 0x70, 0x65,
	0x72, 0x42, 0x6f, 0x75, 0x6e, 0x64, 0x12, 0x14, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x09, 0x3a, 0x00, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x1e, 0x0a, 0x07,
	0x69, 0x73, 0x5f, 0x6c, 0x61, 0x7a, 0x79, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x3a, 0x05, 0x66,
	0x61, 0x6c, 0x73, 0x65, 0x52, 0x06, 0x69, 0x73, 0x4c, 0x61, 0x7a, 0x79, 0x22, 0x80, 0x06, 0x0a,
	0x18, 0x4d, 0x50, 0x47, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x6c, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72,
	0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x14, 0x0a, 0x04, 0x6e, 0x61, 0x6d,
	0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x3a, 0x00, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12,
	0x5f, 0x0a, 0x14, 0x69, 0x6e, 0x64, 0x69, 0x63, 0x61, 0x74, 0x6f, 0x72, 0x5f, 0x63, 0x6f, 0x6e,
	0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2a, 0x2e,
	0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61,
	0x72, 0x63, 0x68, 0x2e, 0x4d, 0x50, 0x49, 0x6e, 0x64, 0x69, 0x63, 0x61, 0x74, 0x6f, 0x72, 0x43,
	0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x48, 0x00, 0x52, 0x13, 0x69, 0x6e, 0x64,
	0x69, 0x63, 0x61, 0x74, 0x6f, 0x72, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74,
	0x12, 0x4d, 0x0a, 0x0e, 0x73, 0x6f, 0x73, 0x5f, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69,
	0x6e, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x4d,
	0x50, 0x53, 0x6f, 0x73, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x48, 0x00,
	0x52, 0x0d, 0x73, 0x6f, 0x73, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x12,
	0x5f, 0x0a, 0x14, 0x71, 0x75, 0x61, 0x64, 0x72, 0x61, 0x74, 0x69, 0x63, 0x5f, 0x63, 0x6f, 0x6e,
	0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2a, 0x2e,
	0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61,
	0x72, 0x63, 0x68, 0x2e, 0x4d, 0x50, 0x51, 0x75, 0x61, 0x64, 0x72, 0x61, 0x74, 0x69, 0x63, 0x43,
	0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x48, 0x00, 0x52, 0x13, 0x71, 0x75, 0x61,
	0x64, 0x72, 0x61, 0x74, 0x69, 0x63, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74,
	0x12, 0x4d, 0x0a, 0x0e, 0x61, 0x62, 0x73, 0x5f, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69,
	0x6e, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x4d,
	0x50, 0x41, 0x62, 0x73, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x48, 0x00,
	0x52, 0x0d, 0x61, 0x62, 0x73, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x12,
	0x4f, 0x0a, 0x0e, 0x61, 0x6e, 0x64, 0x5f, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e,
	0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x4d, 0x50,
	0x41, 0x72, 0x72, 0x61, 0x79, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x48,
	0x00, 0x52, 0x0d, 0x61, 0x6e, 0x64, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74,
	0x12, 0x4d, 0x0a, 0x0d, 0x6f, 0x72, 0x5f, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e,
	0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x4d, 0x50,
	0x41, 0x72, 0x72, 0x61, 0x79, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x48,
	0x00, 0x52, 0x0c, 0x6f, 0x72, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x12,
	0x5b, 0x0a, 0x0e, 0x6d, 0x69, 0x6e, 0x5f, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e,
	0x74, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x32, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x4d, 0x50,
	0x41, 0x72, 0x72, 0x61, 0x79, 0x57, 0x69, 0x74, 0x68, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e,
	0x74, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x48, 0x00, 0x52, 0x0d, 0x6d,
	0x69, 0x6e, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x12, 0x5b, 0x0a, 0x0e,
	0x6d, 0x61, 0x78, 0x5f, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x18, 0x09,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x32, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x4d, 0x50, 0x41, 0x72, 0x72,
	0x61, 0x79, 0x57, 0x69, 0x74, 0x68, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x43, 0x6f,
	0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x48, 0x00, 0x52, 0x0d, 0x6d, 0x61, 0x78, 0x43,
	0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x42, 0x14, 0x0a, 0x12, 0x67, 0x65, 0x6e,
	0x65, 0x72, 0x61, 0x6c, 0x5f, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x22,
	0x99, 0x01, 0x0a, 0x15, 0x4d, 0x50, 0x49, 0x6e, 0x64, 0x69, 0x63, 0x61, 0x74, 0x6f, 0x72, 0x43,
	0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x76, 0x61, 0x72,
	0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x08, 0x76, 0x61,
	0x72, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x12, 0x1b, 0x0a, 0x09, 0x76, 0x61, 0x72, 0x5f, 0x76, 0x61,
	0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x08, 0x76, 0x61, 0x72, 0x56, 0x61,
	0x6c, 0x75, 0x65, 0x12, 0x46, 0x0a, 0x0a, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e,
	0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x4d, 0x50,
	0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x52,
	0x0a, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x22, 0xb7, 0x01, 0x0a, 0x0f,
	0x4d, 0x50, 0x53, 0x6f, 0x73, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x12,
	0x4b, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x29, 0x2e,
	0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61,
	0x72, 0x63, 0x68, 0x2e, 0x4d, 0x50, 0x53, 0x6f, 0x73, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61,
	0x69, 0x6e, 0x74, 0x2e, 0x54, 0x79, 0x70, 0x65, 0x3a, 0x0c, 0x53, 0x4f, 0x53, 0x31, 0x5f, 0x44,
	0x45, 0x46, 0x41, 0x55, 0x4c, 0x54, 0x52, 0x04, 0x74, 0x79, 0x70, 0x65, 0x12, 0x1b, 0x0a, 0x09,
	0x76, 0x61, 0x72, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x02, 0x20, 0x03, 0x28, 0x05, 0x52,
	0x08, 0x76, 0x61, 0x72, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x12, 0x16, 0x0a, 0x06, 0x77, 0x65, 0x69,
	0x67, 0x68, 0x74, 0x18, 0x03, 0x20, 0x03, 0x28, 0x01, 0x52, 0x06, 0x77, 0x65, 0x69, 0x67, 0x68,
	0x74, 0x22, 0x22, 0x0a, 0x04, 0x54, 0x79, 0x70, 0x65, 0x12, 0x10, 0x0a, 0x0c, 0x53, 0x4f, 0x53,
	0x31, 0x5f, 0x44, 0x45, 0x46, 0x41, 0x55, 0x4c, 0x54, 0x10, 0x00, 0x12, 0x08, 0x0a, 0x04, 0x53,
	0x4f, 0x53, 0x32, 0x10, 0x01, 0x22, 0x89, 0x02, 0x0a, 0x15, 0x4d, 0x50, 0x51, 0x75, 0x61, 0x64,
	0x72, 0x61, 0x74, 0x69, 0x63, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x12,
	0x1b, 0x0a, 0x09, 0x76, 0x61, 0x72, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x01, 0x20, 0x03,
	0x28, 0x05, 0x52, 0x08, 0x76, 0x61, 0x72, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x12, 0x20, 0x0a, 0x0b,
	0x63, 0x6f, 0x65, 0x66, 0x66, 0x69, 0x63, 0x69, 0x65, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x03, 0x28,
	0x01, 0x52, 0x0b, 0x63, 0x6f, 0x65, 0x66, 0x66, 0x69, 0x63, 0x69, 0x65, 0x6e, 0x74, 0x12, 0x1f,
	0x0a, 0x0b, 0x71, 0x76, 0x61, 0x72, 0x31, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x03, 0x20,
	0x03, 0x28, 0x05, 0x52, 0x0a, 0x71, 0x76, 0x61, 0x72, 0x31, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x12,
	0x1f, 0x0a, 0x0b, 0x71, 0x76, 0x61, 0x72, 0x32, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x04,
	0x20, 0x03, 0x28, 0x05, 0x52, 0x0a, 0x71, 0x76, 0x61, 0x72, 0x32, 0x49, 0x6e, 0x64, 0x65, 0x78,
	0x12, 0x22, 0x0a, 0x0c, 0x71, 0x63, 0x6f, 0x65, 0x66, 0x66, 0x69, 0x63, 0x69, 0x65, 0x6e, 0x74,
	0x18, 0x05, 0x20, 0x03, 0x28, 0x01, 0x52, 0x0c, 0x71, 0x63, 0x6f, 0x65, 0x66, 0x66, 0x69, 0x63,
	0x69, 0x65, 0x6e, 0x74, 0x12, 0x25, 0x0a, 0x0b, 0x6c, 0x6f, 0x77, 0x65, 0x72, 0x5f, 0x62, 0x6f,
	0x75, 0x6e, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x01, 0x3a, 0x04, 0x2d, 0x69, 0x6e, 0x66, 0x52,
	0x0a, 0x6c, 0x6f, 0x77, 0x65, 0x72, 0x42, 0x6f, 0x75, 0x6e, 0x64, 0x12, 0x24, 0x0a, 0x0b, 0x75,
	0x70, 0x70, 0x65, 0x72, 0x5f, 0x62, 0x6f, 0x75, 0x6e, 0x64, 0x18, 0x07, 0x20, 0x01, 0x28, 0x01,
	0x3a, 0x03, 0x69, 0x6e, 0x66, 0x52, 0x0a, 0x75, 0x70, 0x70, 0x65, 0x72, 0x42, 0x6f, 0x75, 0x6e,
	0x64, 0x22, 0x5e, 0x0a, 0x0f, 0x4d, 0x50, 0x41, 0x62, 0x73, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72,
	0x61, 0x69, 0x6e, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x76, 0x61, 0x72, 0x5f, 0x69, 0x6e, 0x64, 0x65,
	0x78, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x08, 0x76, 0x61, 0x72, 0x49, 0x6e, 0x64, 0x65,
	0x78, 0x12, 0x2e, 0x0a, 0x13, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x61, 0x6e, 0x74, 0x5f, 0x76,
	0x61, 0x72, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x11,
	0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x61, 0x6e, 0x74, 0x56, 0x61, 0x72, 0x49, 0x6e, 0x64, 0x65,
	0x78, 0x22, 0x60, 0x0a, 0x11, 0x4d, 0x50, 0x41, 0x72, 0x72, 0x61, 0x79, 0x43, 0x6f, 0x6e, 0x73,
	0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x76, 0x61, 0x72, 0x5f, 0x69, 0x6e,
	0x64, 0x65, 0x78, 0x18, 0x01, 0x20, 0x03, 0x28, 0x05, 0x52, 0x08, 0x76, 0x61, 0x72, 0x49, 0x6e,
	0x64, 0x65, 0x78, 0x12, 0x2e, 0x0a, 0x13, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x61, 0x6e, 0x74,
	0x5f, 0x76, 0x61, 0x72, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05,
	0x52, 0x11, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x61, 0x6e, 0x74, 0x56, 0x61, 0x72, 0x49, 0x6e,
	0x64, 0x65, 0x78, 0x22, 0x88, 0x01, 0x0a, 0x1d, 0x4d, 0x50, 0x41, 0x72, 0x72, 0x61, 0x79, 0x57,
	0x69, 0x74, 0x68, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x43, 0x6f, 0x6e, 0x73, 0x74,
	0x72, 0x61, 0x69, 0x6e, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x76, 0x61, 0x72, 0x5f, 0x69, 0x6e, 0x64,
	0x65, 0x78, 0x18, 0x01, 0x20, 0x03, 0x28, 0x05, 0x52, 0x08, 0x76, 0x61, 0x72, 0x49, 0x6e, 0x64,
	0x65, 0x78, 0x12, 0x1a, 0x0a, 0x08, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x01, 0x52, 0x08, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x12, 0x2e,
	0x0a, 0x13, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x61, 0x6e, 0x74, 0x5f, 0x76, 0x61, 0x72, 0x5f,
	0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x11, 0x72, 0x65, 0x73,
	0x75, 0x6c, 0x74, 0x61, 0x6e, 0x74, 0x56, 0x61, 0x72, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x22, 0x7a,
	0x0a, 0x14, 0x4d, 0x50, 0x51, 0x75, 0x61, 0x64, 0x72, 0x61, 0x74, 0x69, 0x63, 0x4f, 0x62, 0x6a,
	0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x12, 0x1f, 0x0a, 0x0b, 0x71, 0x76, 0x61, 0x72, 0x31, 0x5f,
	0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x01, 0x20, 0x03, 0x28, 0x05, 0x52, 0x0a, 0x71, 0x76, 0x61,
	0x72, 0x31, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x12, 0x1f, 0x0a, 0x0b, 0x71, 0x76, 0x61, 0x72, 0x32,
	0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x02, 0x20, 0x03, 0x28, 0x05, 0x52, 0x0a, 0x71, 0x76,
	0x61, 0x72, 0x32, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x12, 0x20, 0x0a, 0x0b, 0x63, 0x6f, 0x65, 0x66,
	0x66, 0x69, 0x63, 0x69, 0x65, 0x6e, 0x74, 0x18, 0x03, 0x20, 0x03, 0x28, 0x01, 0x52, 0x0b, 0x63,
	0x6f, 0x65, 0x66, 0x66, 0x69, 0x63, 0x69, 0x65, 0x6e, 0x74, 0x22, 0x5d, 0x0a, 0x19, 0x50, 0x61,
	0x72, 0x74, 0x69, 0x61, 0x6c, 0x56, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x41, 0x73, 0x73,
	0x69, 0x67, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x12, 0x1f, 0x0a, 0x09, 0x76, 0x61, 0x72, 0x5f, 0x69,
	0x6e, 0x64, 0x65, 0x78, 0x18, 0x01, 0x20, 0x03, 0x28, 0x05, 0x42, 0x02, 0x10, 0x01, 0x52, 0x08,
	0x76, 0x61, 0x72, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x12, 0x1f, 0x0a, 0x09, 0x76, 0x61, 0x72, 0x5f,
	0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x03, 0x28, 0x01, 0x42, 0x02, 0x10, 0x01, 0x52,
	0x08, 0x76, 0x61, 0x72, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x22, 0x8e, 0x04, 0x0a, 0x0c, 0x4d, 0x50,
	0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x40, 0x0a, 0x08, 0x76, 0x61,
	0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x6f,
	0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72,
	0x63, 0x68, 0x2e, 0x4d, 0x50, 0x56, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x50, 0x72, 0x6f,
	0x74, 0x6f, 0x52, 0x08, 0x76, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x12, 0x46, 0x0a, 0x0a,
	0x63, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b,
	0x32, 0x26, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65,
	0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x4d, 0x50, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61,
	0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x52, 0x0a, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x72,
	0x61, 0x69, 0x6e, 0x74, 0x12, 0x5c, 0x0a, 0x12, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x6c, 0x5f,
	0x63, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x18, 0x07, 0x20, 0x03, 0x28, 0x0b,
	0x32, 0x2d, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65,
	0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x4d, 0x50, 0x47, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x6c,
	0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x52,
	0x11, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x6c, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69,
	0x6e, 0x74, 0x12, 0x21, 0x0a, 0x08, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x69, 0x7a, 0x65, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x08, 0x3a, 0x05, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x52, 0x08, 0x6d, 0x61, 0x78,
	0x69, 0x6d, 0x69, 0x7a, 0x65, 0x12, 0x2c, 0x0a, 0x10, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x69,
	0x76, 0x65, 0x5f, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x01, 0x3a,
	0x01, 0x30, 0x52, 0x0f, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x4f, 0x66, 0x66,
	0x73, 0x65, 0x74, 0x12, 0x5a, 0x0a, 0x13, 0x71, 0x75, 0x61, 0x64, 0x72, 0x61, 0x74, 0x69, 0x63,
	0x5f, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x29, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65,
	0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x4d, 0x50, 0x51, 0x75, 0x61, 0x64, 0x72, 0x61, 0x74,
	0x69, 0x63, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x52, 0x12, 0x71, 0x75, 0x61,
	0x64, 0x72, 0x61, 0x74, 0x69, 0x63, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x12,
	0x14, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x3a, 0x00, 0x52,
	0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x53, 0x0a, 0x0d, 0x73, 0x6f, 0x6c, 0x75, 0x74, 0x69, 0x6f,
	0x6e, 0x5f, 0x68, 0x69, 0x6e, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2e, 0x2e, 0x6f,
	0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72,
	0x63, 0x68, 0x2e, 0x50, 0x61, 0x72, 0x74, 0x69, 0x61, 0x6c, 0x56, 0x61, 0x72, 0x69, 0x61, 0x62,
	0x6c, 0x65, 0x41, 0x73, 0x73, 0x69, 0x67, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x52, 0x0c, 0x73, 0x6f,
	0x6c, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x48, 0x69, 0x6e, 0x74, 0x22, 0x26, 0x0a, 0x0e, 0x4f, 0x70,
	0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x44, 0x6f, 0x75, 0x62, 0x6c, 0x65, 0x12, 0x14, 0x0a, 0x05,
	0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x01, 0x52, 0x05, 0x76, 0x61, 0x6c,
	0x75, 0x65, 0x22, 0x8d, 0x05, 0x0a, 0x18, 0x4d, 0x50, 0x53, 0x6f, 0x6c, 0x76, 0x65, 0x72, 0x43,
	0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12,
	0x4d, 0x0a, 0x10, 0x72, 0x65, 0x6c, 0x61, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x6d, 0x69, 0x70, 0x5f,
	0x67, 0x61, 0x70, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x6f, 0x70, 0x65, 0x72,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e,
	0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x44, 0x6f, 0x75, 0x62, 0x6c, 0x65, 0x52, 0x0e,
	0x72, 0x65, 0x6c, 0x61, 0x74, 0x69, 0x76, 0x65, 0x4d, 0x69, 0x70, 0x47, 0x61, 0x70, 0x12, 0x4e,
	0x0a, 0x10, 0x70, 0x72, 0x69, 0x6d, 0x61, 0x6c, 0x5f, 0x74, 0x6f, 0x6c, 0x65, 0x72, 0x61, 0x6e,
	0x63, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x4f,
	0x70, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x44, 0x6f, 0x75, 0x62, 0x6c, 0x65, 0x52, 0x0f, 0x70,
	0x72, 0x69, 0x6d, 0x61, 0x6c, 0x54, 0x6f, 0x6c, 0x65, 0x72, 0x61, 0x6e, 0x63, 0x65, 0x12, 0x4a,
	0x0a, 0x0e, 0x64, 0x75, 0x61, 0x6c, 0x5f, 0x74, 0x6f, 0x6c, 0x65, 0x72, 0x61, 0x6e, 0x63, 0x65,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x4f, 0x70, 0x74,
	0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x44, 0x6f, 0x75, 0x62, 0x6c, 0x65, 0x52, 0x0d, 0x64, 0x75, 0x61,
	0x6c, 0x54, 0x6f, 0x6c, 0x65, 0x72, 0x61, 0x6e, 0x63, 0x65, 0x12, 0x77, 0x0a, 0x0c, 0x6c, 0x70,
	0x5f, 0x61, 0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0e,
	0x32, 0x3f, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65,
	0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x4d, 0x50, 0x53, 0x6f, 0x6c, 0x76, 0x65, 0x72, 0x43,
	0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x2e,
	0x4c, 0x50, 0x41, 0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d, 0x56, 0x61, 0x6c, 0x75, 0x65,
	0x73, 0x3a, 0x13, 0x4c, 0x50, 0x5f, 0x41, 0x4c, 0x47, 0x4f, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45,
	0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x52, 0x0b, 0x6c, 0x70, 0x41, 0x6c, 0x67, 0x6f, 0x72, 0x69,
	0x74, 0x68, 0x6d, 0x12, 0x52, 0x0a, 0x08, 0x70, 0x72, 0x65, 0x73, 0x6f, 0x6c, 0x76, 0x65, 0x18,
	0x05, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x24, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x4f, 0x70, 0x74, 0x69,
	0x6f, 0x6e, 0x61, 0x6c, 0x42, 0x6f, 0x6f, 0x6c, 0x65, 0x61, 0x6e, 0x3a, 0x10, 0x42, 0x4f, 0x4f,
	0x4c, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x52, 0x08, 0x70,
	0x72, 0x65, 0x73, 0x6f, 0x6c, 0x76, 0x65, 0x12, 0x50, 0x0a, 0x07, 0x73, 0x63, 0x61, 0x6c, 0x69,
	0x6e, 0x67, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x24, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x4f,
	0x70, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x42, 0x6f, 0x6f, 0x6c, 0x65, 0x61, 0x6e, 0x3a, 0x10,
	0x42, 0x4f, 0x4f, 0x4c, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44,
	0x52, 0x07, 0x73, 0x63, 0x61, 0x6c, 0x69, 0x6e, 0x67, 0x22, 0x67, 0x0a, 0x11, 0x4c, 0x50, 0x41,
	0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x12, 0x17,
	0x0a, 0x13, 0x4c, 0x50, 0x5f, 0x41, 0x4c, 0x47, 0x4f, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43,
	0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x10, 0x0a, 0x0c, 0x4c, 0x50, 0x5f, 0x41, 0x4c,
	0x47, 0x4f, 0x5f, 0x44, 0x55, 0x41, 0x4c, 0x10, 0x01, 0x12, 0x12, 0x0a, 0x0e, 0x4c, 0x50, 0x5f,
	0x41, 0x4c, 0x47, 0x4f, 0x5f, 0x50, 0x52, 0x49, 0x4d, 0x41, 0x4c, 0x10, 0x02, 0x12, 0x13, 0x0a,
	0x0f, 0x4c, 0x50, 0x5f, 0x41, 0x4c, 0x47, 0x4f, 0x5f, 0x42, 0x41, 0x52, 0x52, 0x49, 0x45, 0x52,
	0x10, 0x03, 0x22, 0x8a, 0x04, 0x0a, 0x11, 0x4d, 0x50, 0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x44, 0x65,
	0x6c, 0x74, 0x61, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x37, 0x0a, 0x18, 0x62, 0x61, 0x73, 0x65,
	0x6c, 0x69, 0x6e, 0x65, 0x5f, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x5f, 0x66, 0x69, 0x6c, 0x65, 0x5f,
	0x70, 0x61, 0x74, 0x68, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x15, 0x62, 0x61, 0x73, 0x65,
	0x6c, 0x69, 0x6e, 0x65, 0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x46, 0x69, 0x6c, 0x65, 0x50, 0x61, 0x74,
	0x68, 0x12, 0x6c, 0x0a, 0x12, 0x76, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x6f, 0x76,
	0x65, 0x72, 0x72, 0x69, 0x64, 0x65, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x3d, 0x2e,
	0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61,
	0x72, 0x63, 0x68, 0x2e, 0x4d, 0x50, 0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x44, 0x65, 0x6c, 0x74, 0x61,
	0x50, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x56, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x4f, 0x76,
	0x65, 0x72, 0x72, 0x69, 0x64, 0x65, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x11, 0x76, 0x61,
	0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x4f, 0x76, 0x65, 0x72, 0x72, 0x69, 0x64, 0x65, 0x73, 0x12,
	0x72, 0x0a, 0x14, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x5f, 0x6f, 0x76,
	0x65, 0x72, 0x72, 0x69, 0x64, 0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x3f, 0x2e,
	0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61,
	0x72, 0x63, 0x68, 0x2e, 0x4d, 0x50, 0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x44, 0x65, 0x6c, 0x74, 0x61,
	0x50, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74,
	0x4f, 0x76, 0x65, 0x72, 0x72, 0x69, 0x64, 0x65, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x13,
	0x63, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x4f, 0x76, 0x65, 0x72, 0x72, 0x69,
	0x64, 0x65, 0x73, 0x1a, 0x6a, 0x0a, 0x16, 0x56, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x4f,
	0x76, 0x65, 0x72, 0x72, 0x69, 0x64, 0x65, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a,
	0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12,
	0x3a, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24,
	0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65,
	0x61, 0x72, 0x63, 0x68, 0x2e, 0x4d, 0x50, 0x56, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x50,
	0x72, 0x6f, 0x74, 0x6f, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x1a,
	0x6e, 0x0a, 0x18, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x4f, 0x76, 0x65,
	0x72, 0x72, 0x69, 0x64, 0x65, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b,
	0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x3c, 0x0a,
	0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x6f,
	0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72,
	0x63, 0x68, 0x2e, 0x4d, 0x50, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50,
	0x72, 0x6f, 0x74, 0x6f, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22,
	0xa5, 0x07, 0x0a, 0x0e, 0x4d, 0x50, 0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x52, 0x65, 0x71, 0x75, 0x65,
	0x73, 0x74, 0x12, 0x37, 0x0a, 0x05, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x21, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72,
	0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x4d, 0x50, 0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x50,
	0x72, 0x6f, 0x74, 0x6f, 0x52, 0x05, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x12, 0x4f, 0x0a, 0x0b, 0x73,
	0x6f, 0x6c, 0x76, 0x65, 0x72, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e,
	0x32, 0x2e, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65,
	0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x4d, 0x50, 0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x52, 0x65,
	0x71, 0x75, 0x65, 0x73, 0x74, 0x2e, 0x53, 0x6f, 0x6c, 0x76, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65,
	0x52, 0x0a, 0x73, 0x6f, 0x6c, 0x76, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x12, 0x39, 0x0a, 0x19,
	0x73, 0x6f, 0x6c, 0x76, 0x65, 0x72, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x6c, 0x69, 0x6d, 0x69,
	0x74, 0x5f, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x01, 0x52,
	0x16, 0x73, 0x6f, 0x6c, 0x76, 0x65, 0x72, 0x54, 0x69, 0x6d, 0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74,
	0x53, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x12, 0x48, 0x0a, 0x1d, 0x65, 0x6e, 0x61, 0x62, 0x6c,
	0x65, 0x5f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x5f, 0x73, 0x6f, 0x6c, 0x76, 0x65,
	0x72, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x3a, 0x05,
	0x66, 0x61, 0x6c, 0x73, 0x65, 0x52, 0x1a, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x49, 0x6e, 0x74,
	0x65, 0x72, 0x6e, 0x61, 0x6c, 0x53, 0x6f, 0x6c, 0x76, 0x65, 0x72, 0x4f, 0x75, 0x74, 0x70, 0x75,
	0x74, 0x12, 0x3c, 0x0a, 0x1a, 0x73, 0x6f, 0x6c, 0x76, 0x65, 0x72, 0x5f, 0x73, 0x70, 0x65, 0x63,
	0x69, 0x66, 0x69, 0x63, 0x5f, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x18,
	0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x18, 0x73, 0x6f, 0x6c, 0x76, 0x65, 0x72, 0x53, 0x70, 0x65,
	0x63, 0x69, 0x66, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12,
	0x47, 0x0a, 0x0b, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x5f, 0x64, 0x65, 0x6c, 0x74, 0x61, 0x18, 0x08,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x4d, 0x50, 0x4d, 0x6f, 0x64,
	0x65, 0x6c, 0x44, 0x65, 0x6c, 0x74, 0x61, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x52, 0x0a, 0x6d, 0x6f,
	0x64, 0x65, 0x6c, 0x44, 0x65, 0x6c, 0x74, 0x61, 0x22, 0xfc, 0x03, 0x0a, 0x0a, 0x53, 0x6f, 0x6c,
	0x76, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x12, 0x1b, 0x0a, 0x17, 0x47, 0x4c, 0x4f, 0x50, 0x5f,
	0x4c, 0x49, 0x4e, 0x45, 0x41, 0x52, 0x5f, 0x50, 0x52, 0x4f, 0x47, 0x52, 0x41, 0x4d, 0x4d, 0x49,
	0x4e, 0x47, 0x10, 0x02, 0x12, 0x1a, 0x0a, 0x16, 0x43, 0x4c, 0x50, 0x5f, 0x4c, 0x49, 0x4e, 0x45,
	0x41, 0x52, 0x5f, 0x50, 0x52, 0x4f, 0x47, 0x52, 0x41, 0x4d, 0x4d, 0x49, 0x4e, 0x47, 0x10, 0x00,
	0x12, 0x1b, 0x0a, 0x17, 0x47, 0x4c, 0x50, 0x4b, 0x5f, 0x4c, 0x49, 0x4e, 0x45, 0x41, 0x52, 0x5f,
	0x50, 0x52, 0x4f, 0x47, 0x52, 0x41, 0x4d, 0x4d, 0x49, 0x4e, 0x47, 0x10, 0x01, 0x12, 0x1d, 0x0a,
	0x19, 0x47, 0x55, 0x52, 0x4f, 0x42, 0x49, 0x5f, 0x4c, 0x49, 0x4e, 0x45, 0x41, 0x52, 0x5f, 0x50,
	0x52, 0x4f, 0x47, 0x52, 0x41, 0x4d, 0x4d, 0x49, 0x4e, 0x47, 0x10, 0x06, 0x12, 0x1d, 0x0a, 0x19,
	0x58, 0x50, 0x52, 0x45, 0x53, 0x53, 0x5f, 0x4c, 0x49, 0x4e, 0x45, 0x41, 0x52, 0x5f, 0x50, 0x52,
	0x4f, 0x47, 0x52, 0x41, 0x4d, 0x4d, 0x49, 0x4e, 0x47, 0x10, 0x65, 0x12, 0x1c, 0x0a, 0x18, 0x43,
	0x50, 0x4c, 0x45, 0x58, 0x5f, 0x4c, 0x49, 0x4e, 0x45, 0x41, 0x52, 0x5f, 0x50, 0x52, 0x4f, 0x47,
	0x52, 0x41, 0x4d, 0x4d, 0x49, 0x4e, 0x47, 0x10, 0x0a, 0x12, 0x22, 0x0a, 0x1e, 0x53, 0x43, 0x49,
	0x50, 0x5f, 0x4d, 0x49, 0x58, 0x45, 0x44, 0x5f, 0x49, 0x4e, 0x54, 0x45, 0x47, 0x45, 0x52, 0x5f,
	0x50, 0x52, 0x4f, 0x47, 0x52, 0x41, 0x4d, 0x4d, 0x49, 0x4e, 0x47, 0x10, 0x03, 0x12, 0x22, 0x0a,
	0x1e, 0x47, 0x4c, 0x50, 0x4b, 0x5f, 0x4d, 0x49, 0x58, 0x45, 0x44, 0x5f, 0x49, 0x4e, 0x54, 0x45,
	0x47, 0x45, 0x52, 0x5f, 0x50, 0x52, 0x4f, 0x47, 0x52, 0x41, 0x4d, 0x4d, 0x49, 0x4e, 0x47, 0x10,
	0x04, 0x12, 0x21, 0x0a, 0x1d, 0x43, 0x42, 0x43, 0x5f, 0x4d, 0x49, 0x58, 0x45, 0x44, 0x5f, 0x49,
	0x4e, 0x54, 0x45, 0x47, 0x45, 0x52, 0x5f, 0x50, 0x52, 0x4f, 0x47, 0x52, 0x41, 0x4d, 0x4d, 0x49,
	0x4e, 0x47, 0x10, 0x05, 0x12, 0x24, 0x0a, 0x20, 0x47, 0x55, 0x52, 0x4f, 0x42, 0x49, 0x5f, 0x4d,
	0x49, 0x58, 0x45, 0x44, 0x5f, 0x49, 0x4e, 0x54, 0x45, 0x47, 0x45, 0x52, 0x5f, 0x50, 0x52, 0x4f,
	0x47, 0x52, 0x41, 0x4d, 0x4d, 0x49, 0x4e, 0x47, 0x10, 0x07, 0x12, 0x24, 0x0a, 0x20, 0x58, 0x50,
	0x52, 0x45, 0x53, 0x53, 0x5f, 0x4d, 0x49, 0x58, 0x45, 0x44, 0x5f, 0x49, 0x4e, 0x54, 0x45, 0x47,
	0x45, 0x52, 0x5f, 0x50, 0x52, 0x4f, 0x47, 0x52, 0x41, 0x4d, 0x4d, 0x49, 0x4e, 0x47, 0x10, 0x66,
	0x12, 0x23, 0x0a, 0x1f, 0x43, 0x50, 0x4c, 0x45, 0x58, 0x5f, 0x4d, 0x49, 0x58, 0x45, 0x44, 0x5f,
	0x49, 0x4e, 0x54, 0x45, 0x47, 0x45, 0x52, 0x5f, 0x50, 0x52, 0x4f, 0x47, 0x52, 0x41, 0x4d, 0x4d,
	0x49, 0x4e, 0x47, 0x10, 0x0b, 0x12, 0x1b, 0x0a, 0x17, 0x42, 0x4f, 0x50, 0x5f, 0x49, 0x4e, 0x54,
	0x45, 0x47, 0x45, 0x52, 0x5f, 0x50, 0x52, 0x4f, 0x47, 0x52, 0x41, 0x4d, 0x4d, 0x49, 0x4e, 0x47,
	0x10, 0x0c, 0x12, 0x1b, 0x0a, 0x17, 0x53, 0x41, 0x54, 0x5f, 0x49, 0x4e, 0x54, 0x45, 0x47, 0x45,
	0x52, 0x5f, 0x50, 0x52, 0x4f, 0x47, 0x52, 0x41, 0x4d, 0x4d, 0x49, 0x4e, 0x47, 0x10, 0x0e, 0x12,
	0x26, 0x0a, 0x22, 0x4b, 0x4e, 0x41, 0x50, 0x53, 0x41, 0x43, 0x4b, 0x5f, 0x4d, 0x49, 0x58, 0x45,
	0x44, 0x5f, 0x49, 0x4e, 0x54, 0x45, 0x47, 0x45, 0x52, 0x5f, 0x50, 0x52, 0x4f, 0x47, 0x52, 0x41,
	0x4d, 0x4d, 0x49, 0x4e, 0x47, 0x10, 0x0d, 0x22, 0xe1, 0x02, 0x0a, 0x12, 0x4d, 0x50, 0x53, 0x6f,
	0x6c, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x5c,
	0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x2b,
	0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65,
	0x61, 0x72, 0x63, 0x68, 0x2e, 0x4d, 0x50, 0x53, 0x6f, 0x6c, 0x76, 0x65, 0x72, 0x52, 0x65, 0x73,
	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x3a, 0x17, 0x4d, 0x50, 0x53,
	0x4f, 0x4c, 0x56, 0x45, 0x52, 0x5f, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x5f, 0x53, 0x54,
	0x41, 0x54, 0x55, 0x53, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x1d, 0x0a, 0x0a,
	0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x5f, 0x73, 0x74, 0x72, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x09, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x53, 0x74, 0x72, 0x12, 0x27, 0x0a, 0x0f, 0x6f,
	0x62, 0x6a, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x01, 0x52, 0x0e, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x56,
	0x61, 0x6c, 0x75, 0x65, 0x12, 0x30, 0x0a, 0x14, 0x62, 0x65, 0x73, 0x74, 0x5f, 0x6f, 0x62, 0x6a,
	0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x62, 0x6f, 0x75, 0x6e, 0x64, 0x18, 0x05, 0x20, 0x01,
	0x28, 0x01, 0x52, 0x12, 0x62, 0x65, 0x73, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x69, 0x76,
	0x65, 0x42, 0x6f, 0x75, 0x6e, 0x64, 0x12, 0x29, 0x0a, 0x0e, 0x76, 0x61, 0x72, 0x69, 0x61, 0x62,
	0x6c, 0x65, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x03, 0x20, 0x03, 0x28, 0x01, 0x42, 0x02,
	0x10, 0x01, 0x52, 0x0d, 0x76, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x56, 0x61, 0x6c, 0x75,
	0x65, 0x12, 0x21, 0x0a, 0x0a, 0x64, 0x75, 0x61, 0x6c, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18,
	0x04, 0x20, 0x03, 0x28, 0x01, 0x42, 0x02, 0x10, 0x01, 0x52, 0x09, 0x64, 0x75, 0x61, 0x6c, 0x56,
	0x61, 0x6c, 0x75, 0x65, 0x12, 0x25, 0x0a, 0x0c, 0x72, 0x65, 0x64, 0x75, 0x63, 0x65, 0x64, 0x5f,
	0x63, 0x6f, 0x73, 0x74, 0x18, 0x06, 0x20, 0x03, 0x28, 0x01, 0x42, 0x02, 0x10, 0x01, 0x52, 0x0b,
	0x72, 0x65, 0x64, 0x75, 0x63, 0x65, 0x64, 0x43, 0x6f, 0x73, 0x74, 0x2a, 0xfa, 0x02, 0x0a, 0x16,
	0x4d, 0x50, 0x53, 0x6f, 0x6c, 0x76, 0x65, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
	0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x14, 0x0a, 0x10, 0x4d, 0x50, 0x53, 0x4f, 0x4c, 0x56,
	0x45, 0x52, 0x5f, 0x4f, 0x50, 0x54, 0x49, 0x4d, 0x41, 0x4c, 0x10, 0x00, 0x12, 0x15, 0x0a, 0x11,
	0x4d, 0x50, 0x53, 0x4f, 0x4c, 0x56, 0x45, 0x52, 0x5f, 0x46, 0x45, 0x41, 0x53, 0x49, 0x42, 0x4c,
	0x45, 0x10, 0x01, 0x12, 0x17, 0x0a, 0x13, 0x4d, 0x50, 0x53, 0x4f, 0x4c, 0x56, 0x45, 0x52, 0x5f,
	0x49, 0x4e, 0x46, 0x45, 0x41, 0x53, 0x49, 0x42, 0x4c, 0x45, 0x10, 0x02, 0x12, 0x16, 0x0a, 0x12,
	0x4d, 0x50, 0x53, 0x4f, 0x4c, 0x56, 0x45, 0x52, 0x5f, 0x55, 0x4e, 0x42, 0x4f, 0x55, 0x4e, 0x44,
	0x45, 0x44, 0x10, 0x03, 0x12, 0x15, 0x0a, 0x11, 0x4d, 0x50, 0x53, 0x4f, 0x4c, 0x56, 0x45, 0x52,
	0x5f, 0x41, 0x42, 0x4e, 0x4f, 0x52, 0x4d, 0x41, 0x4c, 0x10, 0x04, 0x12, 0x17, 0x0a, 0x13, 0x4d,
	0x50, 0x53, 0x4f, 0x4c, 0x56, 0x45, 0x52, 0x5f, 0x4e, 0x4f, 0x54, 0x5f, 0x53, 0x4f, 0x4c, 0x56,
	0x45, 0x44, 0x10, 0x06, 0x12, 0x1b, 0x0a, 0x17, 0x4d, 0x50, 0x53, 0x4f, 0x4c, 0x56, 0x45, 0x52,
	0x5f, 0x4d, 0x4f, 0x44, 0x45, 0x4c, 0x5f, 0x49, 0x53, 0x5f, 0x56, 0x41, 0x4c, 0x49, 0x44, 0x10,
	0x61, 0x12, 0x1b, 0x0a, 0x17, 0x4d, 0x50, 0x53, 0x4f, 0x4c, 0x56, 0x45, 0x52, 0x5f, 0x55, 0x4e,
	0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x10, 0x63, 0x12, 0x1a,
	0x0a, 0x16, 0x4d, 0x50, 0x53, 0x4f, 0x4c, 0x56, 0x45, 0x52, 0x5f, 0x4d, 0x4f, 0x44, 0x45, 0x4c,
	0x5f, 0x49, 0x4e, 0x56, 0x41, 0x4c, 0x49, 0x44, 0x10, 0x05, 0x12, 0x28, 0x0a, 0x24, 0x4d, 0x50,
	0x53, 0x4f, 0x4c, 0x56, 0x45, 0x52, 0x5f, 0x4d, 0x4f, 0x44, 0x45, 0x4c, 0x5f, 0x49, 0x4e, 0x56,
	0x41, 0x4c, 0x49, 0x44, 0x5f, 0x53, 0x4f, 0x4c, 0x55, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x48, 0x49,
	0x4e, 0x54, 0x10, 0x54, 0x12, 0x2c, 0x0a, 0x28, 0x4d, 0x50, 0x53, 0x4f, 0x4c, 0x56, 0x45, 0x52,
	0x5f, 0x4d, 0x4f, 0x44, 0x45, 0x4c, 0x5f, 0x49, 0x4e, 0x56, 0x41, 0x4c, 0x49, 0x44, 0x5f, 0x53,
	0x4f, 0x4c, 0x56, 0x45, 0x52, 0x5f, 0x50, 0x41, 0x52, 0x41, 0x4d, 0x45, 0x54, 0x45, 0x52, 0x53,
	0x10, 0x55, 0x12, 0x24, 0x0a, 0x20, 0x4d, 0x50, 0x53, 0x4f, 0x4c, 0x56, 0x45, 0x52, 0x5f, 0x53,
	0x4f, 0x4c, 0x56, 0x45, 0x52, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x55, 0x4e, 0x41, 0x56, 0x41,
	0x49, 0x4c, 0x41, 0x42, 0x4c, 0x45, 0x10, 0x07, 0x42, 0x49, 0x0a, 0x1f, 0x63, 0x6f, 0x6d, 0x2e,
	0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x6f, 0x72, 0x74, 0x6f, 0x6f, 0x6c, 0x73, 0x2e, 0x6c,
	0x69, 0x6e, 0x65, 0x61, 0x72, 0x73, 0x6f, 0x6c, 0x76, 0x65, 0x72, 0x50, 0x01, 0x5a, 0x24, 0x6f,
	0x72, 0x74, 0x6f, 0x6f, 0x6c, 0x73, 0x2f, 0x67, 0x65, 0x6e, 0x2f, 0x6f, 0x72, 0x74, 0x6f, 0x6f,
	0x6c, 0x73, 0x2f, 0x67, 0x6f, 0x2f, 0x6c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x5f, 0x73, 0x6f, 0x6c,
	0x76, 0x65, 0x72,
}

var (
	file_ortools_linear_solver_linear_solver_proto_rawDescOnce sync.Once
	file_ortools_linear_solver_linear_solver_proto_rawDescData = file_ortools_linear_solver_linear_solver_proto_rawDesc
)

func file_ortools_linear_solver_linear_solver_proto_rawDescGZIP() []byte {
	file_ortools_linear_solver_linear_solver_proto_rawDescOnce.Do(func() {
		file_ortools_linear_solver_linear_solver_proto_rawDescData = protoimpl.X.CompressGZIP(file_ortools_linear_solver_linear_solver_proto_rawDescData)
	})
	return file_ortools_linear_solver_linear_solver_proto_rawDescData
}

var file_ortools_linear_solver_linear_solver_proto_enumTypes = make([]protoimpl.EnumInfo, 4)
var file_ortools_linear_solver_linear_solver_proto_msgTypes = make([]protoimpl.MessageInfo, 19)
var file_ortools_linear_solver_linear_solver_proto_goTypes = []interface{}{
	(MPSolverResponseStatus)(0),                     // 0: operations_research.MPSolverResponseStatus
	(MPSosConstraint_Type)(0),                       // 1: operations_research.MPSosConstraint.Type
	(MPSolverCommonParameters_LPAlgorithmValues)(0), // 2: operations_research.MPSolverCommonParameters.LPAlgorithmValues
	(MPModelRequest_SolverType)(0),                  // 3: operations_research.MPModelRequest.SolverType
	(*MPVariableProto)(nil),                         // 4: operations_research.MPVariableProto
	(*MPConstraintProto)(nil),                       // 5: operations_research.MPConstraintProto
	(*MPGeneralConstraintProto)(nil),                // 6: operations_research.MPGeneralConstraintProto
	(*MPIndicatorConstraint)(nil),                   // 7: operations_research.MPIndicatorConstraint
	(*MPSosConstraint)(nil),                         // 8: operations_research.MPSosConstraint
	(*MPQuadraticConstraint)(nil),                   // 9: operations_research.MPQuadraticConstraint
	(*MPAbsConstraint)(nil),                         // 10: operations_research.MPAbsConstraint
	(*MPArrayConstraint)(nil),                       // 11: operations_research.MPArrayConstraint
	(*MPArrayWithConstantConstraint)(nil),           // 12: operations_research.MPArrayWithConstantConstraint
	(*MPQuadraticObjective)(nil),                    // 13: operations_research.MPQuadraticObjective
	(*PartialVariableAssignment)(nil),               // 14: operations_research.PartialVariableAssignment
	(*MPModelProto)(nil),                            // 15: operations_research.MPModelProto
	(*OptionalDouble)(nil),                          // 16: operations_research.OptionalDouble
	(*MPSolverCommonParameters)(nil),                // 17: operations_research.MPSolverCommonParameters
	(*MPModelDeltaProto)(nil),                       // 18: operations_research.MPModelDeltaProto
	(*MPModelRequest)(nil),                          // 19: operations_research.MPModelRequest
	(*MPSolutionResponse)(nil),                      // 20: operations_research.MPSolutionResponse
	nil,                                             // 21: operations_research.MPModelDeltaProto.VariableOverridesEntry
	nil,                                             // 22: operations_research.MPModelDeltaProto.ConstraintOverridesEntry
	(util.OptionalBoolean)(0),                       // 23: operations_research.OptionalBoolean
}
var file_ortools_linear_solver_linear_solver_proto_depIdxs = []int32{
	7,  // 0: operations_research.MPGeneralConstraintProto.indicator_constraint:type_name -> operations_research.MPIndicatorConstraint
	8,  // 1: operations_research.MPGeneralConstraintProto.sos_constraint:type_name -> operations_research.MPSosConstraint
	9,  // 2: operations_research.MPGeneralConstraintProto.quadratic_constraint:type_name -> operations_research.MPQuadraticConstraint
	10, // 3: operations_research.MPGeneralConstraintProto.abs_constraint:type_name -> operations_research.MPAbsConstraint
	11, // 4: operations_research.MPGeneralConstraintProto.and_constraint:type_name -> operations_research.MPArrayConstraint
	11, // 5: operations_research.MPGeneralConstraintProto.or_constraint:type_name -> operations_research.MPArrayConstraint
	12, // 6: operations_research.MPGeneralConstraintProto.min_constraint:type_name -> operations_research.MPArrayWithConstantConstraint
	12, // 7: operations_research.MPGeneralConstraintProto.max_constraint:type_name -> operations_research.MPArrayWithConstantConstraint
	5,  // 8: operations_research.MPIndicatorConstraint.constraint:type_name -> operations_research.MPConstraintProto
	1,  // 9: operations_research.MPSosConstraint.type:type_name -> operations_research.MPSosConstraint.Type
	4,  // 10: operations_research.MPModelProto.variable:type_name -> operations_research.MPVariableProto
	5,  // 11: operations_research.MPModelProto.constraint:type_name -> operations_research.MPConstraintProto
	6,  // 12: operations_research.MPModelProto.general_constraint:type_name -> operations_research.MPGeneralConstraintProto
	13, // 13: operations_research.MPModelProto.quadratic_objective:type_name -> operations_research.MPQuadraticObjective
	14, // 14: operations_research.MPModelProto.solution_hint:type_name -> operations_research.PartialVariableAssignment
	16, // 15: operations_research.MPSolverCommonParameters.relative_mip_gap:type_name -> operations_research.OptionalDouble
	16, // 16: operations_research.MPSolverCommonParameters.primal_tolerance:type_name -> operations_research.OptionalDouble
	16, // 17: operations_research.MPSolverCommonParameters.dual_tolerance:type_name -> operations_research.OptionalDouble
	2,  // 18: operations_research.MPSolverCommonParameters.lp_algorithm:type_name -> operations_research.MPSolverCommonParameters.LPAlgorithmValues
	23, // 19: operations_research.MPSolverCommonParameters.presolve:type_name -> operations_research.OptionalBoolean
	23, // 20: operations_research.MPSolverCommonParameters.scaling:type_name -> operations_research.OptionalBoolean
	21, // 21: operations_research.MPModelDeltaProto.variable_overrides:type_name -> operations_research.MPModelDeltaProto.VariableOverridesEntry
	22, // 22: operations_research.MPModelDeltaProto.constraint_overrides:type_name -> operations_research.MPModelDeltaProto.ConstraintOverridesEntry
	15, // 23: operations_research.MPModelRequest.model:type_name -> operations_research.MPModelProto
	3,  // 24: operations_research.MPModelRequest.solver_type:type_name -> operations_research.MPModelRequest.SolverType
	18, // 25: operations_research.MPModelRequest.model_delta:type_name -> operations_research.MPModelDeltaProto
	0,  // 26: operations_research.MPSolutionResponse.status:type_name -> operations_research.MPSolverResponseStatus
	4,  // 27: operations_research.MPModelDeltaProto.VariableOverridesEntry.value:type_name -> operations_research.MPVariableProto
	5,  // 28: operations_research.MPModelDeltaProto.ConstraintOverridesEntry.value:type_name -> operations_research.MPConstraintProto
	29, // [29:29] is the sub-list for method output_type
	29, // [29:29] is the sub-list for method input_type
	29, // [29:29] is the sub-list for extension type_name
	29, // [29:29] is the sub-list for extension extendee
	0,  // [0:29] is the sub-list for field type_name
}

func init() { file_ortools_linear_solver_linear_solver_proto_init() }
func file_ortools_linear_solver_linear_solver_proto_init() {
	if File_ortools_linear_solver_linear_solver_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_ortools_linear_solver_linear_solver_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MPVariableProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ortools_linear_solver_linear_solver_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MPConstraintProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ortools_linear_solver_linear_solver_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MPGeneralConstraintProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ortools_linear_solver_linear_solver_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MPIndicatorConstraint); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ortools_linear_solver_linear_solver_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MPSosConstraint); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ortools_linear_solver_linear_solver_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MPQuadraticConstraint); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ortools_linear_solver_linear_solver_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MPAbsConstraint); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ortools_linear_solver_linear_solver_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MPArrayConstraint); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ortools_linear_solver_linear_solver_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MPArrayWithConstantConstraint); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ortools_linear_solver_linear_solver_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MPQuadraticObjective); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ortools_linear_solver_linear_solver_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PartialVariableAssignment); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ortools_linear_solver_linear_solver_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MPModelProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ortools_linear_solver_linear_solver_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*OptionalDouble); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ortools_linear_solver_linear_solver_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MPSolverCommonParameters); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ortools_linear_solver_linear_solver_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MPModelDeltaProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ortools_linear_solver_linear_solver_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MPModelRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ortools_linear_solver_linear_solver_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MPSolutionResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_ortools_linear_solver_linear_solver_proto_msgTypes[2].OneofWrappers = []interface{}{
		(*MPGeneralConstraintProto_IndicatorConstraint)(nil),
		(*MPGeneralConstraintProto_SosConstraint)(nil),
		(*MPGeneralConstraintProto_QuadraticConstraint)(nil),
		(*MPGeneralConstraintProto_AbsConstraint)(nil),
		(*MPGeneralConstraintProto_AndConstraint)(nil),
		(*MPGeneralConstraintProto_OrConstraint)(nil),
		(*MPGeneralConstraintProto_MinConstraint)(nil),
		(*MPGeneralConstraintProto_MaxConstraint)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_ortools_linear_solver_linear_solver_proto_rawDesc,
			NumEnums:      4,
			NumMessages:   19,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_ortools_linear_solver_linear_solver_proto_goTypes,
		DependencyIndexes: file_ortools_linear_solver_linear_solver_proto_depIdxs,
		EnumInfos:         file_ortools_linear_solver_linear_solver_proto_enumTypes,
		MessageInfos:      file_ortools_linear_solver_linear_solver_proto_msgTypes,
	}.Build()
	File_ortools_linear_solver_linear_solver_proto = out.File
	file_ortools_linear_solver_linear_solver_proto_rawDesc = nil
	file_ortools_linear_solver_linear_solver_proto_goTypes = nil
	file_ortools_linear_solver_linear_solver_proto_depIdxs = nil
}
